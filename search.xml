<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring-Data-Redis操作redis服务器]]></title>
    <url>%2Fdlh1234okok.github.io%2F2018%2F10%2F27%2FSpring-Data-Redis%E6%93%8D%E4%BD%9Credis%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[进行spring操作前，需要将redis配置中的所有127.0.0.1改为本机ip 加入坐标依赖1234567891011121314151617181920212223&lt;dependencies&gt;&lt;dependency&gt;&lt;groupId&gt;junit&lt;/groupId&gt;&lt;artifactId&gt;junit&lt;/artifactId&gt;&lt;version&gt;4.12&lt;/version&gt;&lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework&lt;/groupId&gt;&lt;artifactId&gt;spring-test&lt;/artifactId&gt;&lt;version&gt;4.3.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.data&lt;/groupId&gt;&lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;&lt;version&gt;1.8.1.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;redis.clients&lt;/groupId&gt;&lt;artifactId&gt;jedis&lt;/artifactId&gt;&lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;/dependencies&gt; 添加application.xml配置文件1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 连接池配置 --&gt; &lt;bean id="jedisPoolConfig" class="redis.clients.jedis.JedisPoolConfig"&gt; &lt;!-- 最大连接数 --&gt; &lt;property name="maxTotal" value="1024"/&gt; &lt;!-- 最大 空闲连接数 --&gt; &lt;property name="maxIdle" value="200"/&gt; &lt;!-- 获取连接时最大等待毫秒数 --&gt; &lt;property name="maxWaitMillis" value="10000"/&gt; &lt;!-- 在获取连接时检查有效性 --&gt; &lt;property name="testOnBorrow" value="true"/&gt; &lt;/bean&gt; &lt;!-- 客户端连接工厂 --&gt; &lt;bean id="jedisConnFactory" class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory" p:use-pool="true" p:host-name="192.168.1.38" p:port="6380" p:password="123456"&gt; &lt;!-- 连接池引用 --&gt; &lt;constructor-arg name="poolConfig" ref="jedisPoolConfig"/&gt; &lt;/bean&gt; &lt;!-- redisTemplate 配置 --&gt; &lt;bean id="redisTemplate" class="org.springframework.data.redis.core.RedisTemplate" p:connection-factory-ref="jedisConnFactory"&gt; &lt;!-- 配置序列化操作 --&gt; &lt;property name="keySerializer"&gt; &lt;bean class="org.springframework.data.redis.serializer.StringRedisSerializer"/&gt; &lt;/property&gt; &lt;property name="valueSerializer"&gt; &lt;bean class="org.springframework.data.redis.serializer.StringRedisSerializer"/&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 单元测试1234567891011121314151617181920public class TestSpringDataRedis &#123; @Resource RedisTemplate&lt;String,Object&gt; redisTemplate; @Test public void test01() &#123; ValueOperations valueOperations = redisTemplate.opsForValue(); valueOperations.set("redis02", "hello redis"); &#125; // 过期秒数实现 @Test public void test02() &#123; BoundValueOperations&lt;String, Object&gt; Operations = redisTemplate.boundValueOps("18236741290:12 3456"); Operations.append("123456"); System.out.println("验证码:" + Operations.get()); // 设置过期时间 60 秒后过期 Operations.expire(60, TimeUnit.SECONDS); &#125;&#125; Spring环境下读写分离配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 连接池配置 --&gt; &lt;bean id="jedisPoolConfig" class="redis.clients.jedis.JedisPoolConfig"&gt; &lt;!-- 最大连接数 --&gt; &lt;property name="maxTotal" value="1024"/&gt; &lt;!-- 最大 空闲连接数 --&gt; &lt;property name="maxIdle" value="200"/&gt; &lt;!-- 获取连接时最大等待毫秒数 --&gt; &lt;property name="maxWaitMillis" value="10000"/&gt; &lt;!-- 在获取连接时检查有效性 --&gt; &lt;property name="testOnBorrow" value="true"/&gt; &lt;/bean&gt; &lt;bean id="redisSentinelConfiguration" class="org.springframework.data.redis.connection.RedisSentinelConfiguration"&gt; &lt;property name="master"&gt; &lt;bean class="org.springframework.data.redis.connection.RedisNode"&gt; &lt;property name="name" value="mymaster"/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;property name="sentinels"&gt; &lt;set&gt; &lt;bean class="org.springframework.data.redis.connection.RedisNode"&gt; &lt;constructor-arg name="host" value="192.168.1.38"/&gt; &lt;constructor-arg name="port" value="6380"/&gt; &lt;/bean&gt; &lt;bean class="org.springframework.data.redis.connection.RedisNode"&gt; &lt;constructor-arg name="host" value="192.168.1.38"/&gt; &lt;constructor-arg name="port" value="6379"/&gt; &lt;/bean&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 客户端连接工厂 --&gt; &lt;bean id="jedisConnFactory" class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory"&gt; &lt;!-- 连接池引用 --&gt; &lt;constructor-arg name="poolConfig" ref="jedisPoolConfig"/&gt; &lt;constructor-arg name="sentinelConfig" ref="redisSentinelConfiguration"/&gt; &lt;property name="password" value="123456"/&gt; &lt;/bean&gt; &lt;!-- redisTemplate 配置 --&gt; &lt;bean id="redisTemplate" class="org.springframework.data.redis.core.RedisTemplate" p:connection-factory-ref="jedisConnFactory"&gt; &lt;!-- 配置序列化操作 --&gt; &lt;property name="keySerializer"&gt; &lt;bean class="org.springframework.data.redis.serializer.StringRedisSerializer"/&gt; &lt;/property&gt; &lt;property name="valueSerializer"&gt; &lt;bean class="org.springframework.data.redis.serializer.JdkSerializationRedisSerializer"/&gt; &lt;/property&gt; &lt;property name="hashKeySerializer"&gt; &lt;bean class="org.springframework.data.redis.serializer.StringRedisSerializer"/&gt; &lt;/property&gt; &lt;property name="hashValueSerializer"&gt; &lt;bean class="org.springframework.data.redis.serializer.JdkSerializationRedisSerializer"/&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id="redisUtils" class="com.shsxt.utils.RedisUtils"&gt; &lt;constructor-arg name="redisTemplate" ref="redisTemplate"/&gt; &lt;/bean&gt;&lt;/beans&gt;]]></content>
      <categories>
        <category>redis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Redis-JAVA客户端]]></title>
    <url>%2Fdlh1234okok.github.io%2F2018%2F10%2F27%2FRedis%E5%AE%A2%E6%88%B7%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[​ 在前面我们添加的服务器访问密码和bind的设置就是为了连接客户端准备的。 添加依赖123456789101112131415&lt;dependencies&gt;&lt;dependency&gt;&lt;groupId&gt;junit&lt;/groupId&gt;&lt;artifactId&gt;junit&lt;/artifactId&gt;&lt;version&gt;4.12&lt;/version&gt;&lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;redis.clients&lt;/groupId&gt;&lt;artifactId&gt;jedis&lt;/artifactId&gt;&lt;version&gt;2.9.0&lt;/version&gt;&lt;type&gt;jar&lt;/type&gt;&lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;&lt;/dependencies&gt; 通过junit简单测试1234567891011@Testpublic void test01() &#123; // 创建redis客户端连接对象 Jedis jedis = new Jedis("192.168.1.38", 6380); // 设置认证密码 jedis.auth("123456"); // 批量添加string类型数据 jedis.mset("name", "zs", "age", "20", "address", "shanghai"); // 获取缓存数据并输出 System.out.println(jedis.get("name"));&#125; 通过redis连接池获取连接对象并操作服务器123456789@Testpublic void test02() &#123; // 初始化redis客户端连接池 JedisPool jedisPool = new JedisPool(new JedisPoolConfig(), "192.168.1.38", 6380, 10000, "123456"); // 从连接池获取连接 Jedis jedis = jedisPool.getResource(); jedis.set("name","ls"); System.out.println(jedis.get("name"));&#125; 封装RedisUtil对外提供连接对象获取方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class RedisUtils &#123; // redis服务器ip private static String IP = "192.168.1.38"; // redis端口号 private static int PORT = 6380; // redis服务器访问密码 private static String AUTH = "123456"; /** * 可用连接实例的最大数目，默认值为8 * 如果赋值为-1，则表示不限制；如果pool已经分配了maxActive个jedis实例， * 则此时pool的状态为exhausted(耗尽) */ private static int MAX_ACTIVE = 1024; // 控制一个pool最多有多少个状态为idle(空闲)的jedis实例，默认值为8 private static int MAX_IDLE = 200; /** * 等待可用连接的最大时间，单位毫秒，默认值为-1（永不超时）,如果超过等待时间 * 则直接抛出JedisConnectionException */ private static int MAX_WAIT = 10000; private static int TIMEOUT = 10000; /** * 在borrow一个jedis实例时，是否提前进行validate操作；如果为true， * 则得到的jedis实例均是可用的 */ private static boolean TEST_ON_BORROW = true; private static JedisPool jedisPool = null; /** * 初始化redis连接池 */ static &#123; JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(MAX_ACTIVE); config.setMaxIdle(MAX_IDLE); config.setMaxWaitMillis(MAX_WAIT); config.setTestOnBorrow(TEST_ON_BORROW); jedisPool = new JedisPool(config, IP, PORT, TIMEOUT, AUTH); &#125; public RedisUtils(RedisTemplate redisTemplate) &#123; &#125; /** * 获取Jedis实例 */ public synchronized static Jedis getJedis() &#123; if (null != jedisPool) &#123; Jedis resource = jedisPool.getResource(); return resource; &#125; else &#123; return null; &#125; &#125; /** * 释放jedis资源 */ public static void returnResource(final Jedis jedis) &#123; if (null != jedis) jedisPool.close(); &#125;&#125; Jedis客户端操作redis服务器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109public class TestJeditPool &#123; private Jedis jedis; @Before public void init() &#123; jedis = RedisUtils.getJedis(); &#125; /** * string操作 */ @Test public void test01() &#123; jedis.set("one", "hello"); jedis.append("one", "world"); System.out.println(jedis.get("one")); System.out.println("---------------"); jedis.mset("name", "zs", "age", "20", "id", "123456"); List&lt;String&gt; list = jedis.mget("name", "age", "id"); if (null != list &amp;&amp; list.size() &gt; 0) &#123; for (String str : list) System.out.println(str + " "); &#125; System.out.println("---------------"); jedis.incr("age"); System.out.println(jedis.get("age")); jedis.incrBy("age", 10); System.out.println(jedis.get("age")); RedisUtils.returnResource(jedis); &#125; /** * hash操作 */ @Test public void test02() &#123; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put("id", "1"); map.put("name", "zs"); map.put("age", "20"); jedis.hmset("user", map); System.out.println(jedis.hmget("user", "id", "name", "age")); jedis.hdel("user", "age"); System.out.println(jedis.hexists("user", "age")); Set&lt;String&gt; keys = jedis.hkeys("user"); for (String str : keys) System.out.println(str + "-" + jedis.hget("user", str)); &#125; /** * list操作 */ @Test public void test03() &#123; jedis.lpush("test", "h1"); jedis.lpush("test", "h2"); jedis.lpush("test", "h3"); System.out.println(jedis.lrange("test", 0, -1)); System.out.println(jedis.lpop("test")); System.out.println(jedis.lrange("test", 0, -1)); jedis.lrem("test", 0, "h1"); jedis.lrem("test", 1, "h2"); jedis.lrem("test", 2, "h3"); &#125; /** * set操作 */ @Test public void test04() &#123; jedis.sadd("users", "zs"); jedis.sadd("users", "ls"); jedis.sadd("users", "ww"); System.out.println(jedis.smembers("users")); System.out.println(jedis.sismember("users", "zss")); System.out.println(jedis.srandmember("users")); System.out.println(jedis.spop("users")); System.out.println(jedis.scard("users")); RedisUtils.returnResource(jedis); &#125; /** * sort set */ @Test public void test05() &#123; jedis.zadd("stu", 100, "zs"); jedis.zadd("stu", 30, "ls"); jedis.zadd("stu", 60, "ww"); System.out.println(jedis.zrange("stu", 0, -1)); System.out.println(jedis.zrevrange("stu", 0, -1)); System.out.println(jedis.zrangeByScore("stu", 50, 60)); RedisUtils.returnResource(jedis); &#125;&#125;]]></content>
      <categories>
        <category>redis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Redis持久化]]></title>
    <url>%2Fdlh1234okok.github.io%2F2018%2F10%2F27%2FRedis%E6%8C%81%E4%B9%85%E5%8C%96%2F</url>
    <content type="text"><![CDATA[对于 Redis,其提供了不同级别的持久化操作:​ 1、RDB 持久化可以在指定的时间间隔内生成数据集的时间点快照​ 2、AOF 持久化记录服务器执行的所有写操作命令， 并在服务器启动时， 通过重新执行这些命令来还原数据集。 AOF 文件中的命令全部以 Redis 协议的格式来保存， 新命令会被追加到文件的末尾。 Redis 还可以在后台对 AOF 文件进行重写（rewrite）， 使得 AOF文件的体积不会超出保存数据集状态所需的实际大小。 ​ 3、Redis 还可以同时使用 AOF 持久化和 RDB 持久化。在这种情况下， 当 Redis 重启时,它会优先使用 AOF 文件来还原数据集,因为 AOF 文件保存的数据集通常比 RDB文件所保存的数据集更完整。​ 4、持久化功能当然也可以进行关闭操作， 让数据仅在服务器运行时存在 RDB 持久化操作（快照 SnapShot 方式）​ 在默认情况下， Redis 将数据库快照保存在名字为 dump.rdb 的二进制文件中。当然， 这里可以通过修改redis.conf 配置文件来对数据存储条件进行定义， 规定在“ N 秒内数据集至少有 M 个改动”这一条件被满足时,自动保存一次数据集。 也可以通过调用 save 或 bgsave ,手动让 Redis 进行数据集保存操作 Save |Bgsave 手动方式保存数据通过 save 操作 ， 当前 io 操作被阻塞， 当 save 保存执行完毕才会进行后续 io 操作 save 操作执行成功后可以看到 dump.rdb 文件(在 root/usr/redis-4.0.9-master/src 目录下) 快照运行方式当 Redis 需要保存 dump.rdb 文件时， 服务器执行以下操作： Redis 调用 fork() ， 同时拥有父进程和子进程。 子进程将数据集写入到一个临时 RDB 文件中。 当子进程完成对新 RDB 文件的写入时， Redis 用新 RDB 文件替换原来的 RDB 文件， 并删除旧的 RDB 文件。RDB 优缺点 优点: RDB 是一个非常紧凑（compact） 的文件， 它保存了 Redis 在某个时间点上的数据集。 该文件适合用于进行备份 。 比如说， 可以在最近的 24 小时内， 每小时备份一次 RDB 文件， 并且在每个月的每一天， 也备份一个 RDB 文件。 这样的话， 即使遇上问题， 也可以随时将数据集还原到不同的版本。 RDB 非常适用于灾难恢复（disaster recovery） ： 它只有一个文件， 并且内容都非常紧凑，可以（在加密后） 将它传送到别的数据中心 RDB 可以最大化 Redis 的性能： 父进程在保存 RDB 文件时唯一要做的就是 fork 出一个子进程， 然后这个子进程就会处理接下来的所有保存工作， 父进程无须执行任何磁盘 I/O 操作。 RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快 缺点: 如果想要做到数据实时备份级别， 此时使用 rdb 快照进行备份可能会出现数据无法备份完整情况，比如在数据备份完毕下次备份操作发起前， 服务器由于某种原因意外宕机， 此时采用 rdb 就无法对当前情况做的实时响应处理 RDB 需要经常 fork 子进程来保存数据集到硬盘上,当数据集比较大的时候,fork 的过程是非常耗时的,可能会导致Redis在一些毫秒级内不能响应客户端的请求.如果数据集巨大并且CPU性能不是很好的情况下,这种情况会持续 1 秒,AOF 也需要 fork,但是你可以调节重写日志文件的频率来提高数据集的耐久度. AOF 只追加操作的文件​ RDB 需要经常 fork 子进程来保存数据集到硬盘上,当数据集比较大的时候,fork 的过程是非常耗时的,可能会导致 Redis 在一些毫秒级内不能响应客户端的请求.如果数据集巨大并且 CPU 性能不是很好的情况下,这种情况会持续 1 秒,AOF 也需要 fork,但是你可以调节重写日志文件的频率来提高数据集的耐久度. appendonly yes ​ 从现在开始， 每当 Redis 执行一个改变数据集的命令时（比如 SET） ， 这个命令就会被追加到 AOF 文件的末尾。 这样的话， 当 Redis 重新启时， 程序就可以通过重新执行AOF 文件中的命令来达到重建数据集的目的。 日志重写 ​ 因为 AOF 的运作方式是不断地将命令追加到文件的末尾， 所以随着写入命令的不断增加，AOF 文件的体积也会变得越来越大。 举个例子， 如果你对一个计数器调用了 100 次INCR ， 那么仅仅是为了保存这个计数器的当前值， AOF 文件就需要使用 100 条记录（entry） 。 然而在实际上， 只使用一条 SET 命令已经足以保存计数器的当前值了， 其余 99 条记录实际上都是多余的。 ​ 为了处理这种情况， Redis 支持一种有趣的特性： 可以在不打断服务客户端的情况下， 对AOF 文件进行重建（rebuild） 。 执行 BGREWRITEAOF 命令， Redis 将生成一个新的AOF 文件， 这个文件包含重建当前数据集所需的最少命令。 Redis 2.2 需要自己手动执行 BGREWRITEAOF 命令； Redis 2.4 则可以自动触发 AOF 重写。 参考:http://www.redis.cn/topics/persistence.html AOF重写文件配置 1234567891011121314151617181920# 是否开启 AOF， 默认关闭（no）appendonly yes# 指定 AOF 文件名appendfilename appendonly.aof# Redis 支持三种不同的刷写模式：# appendfsync always #每次收到写命令就立即强制写入磁盘， 是最有保证的完全的持久化， 但速度也是最慢的， 一般不推荐使用。appendfsync everysec #每秒钟强制写入磁盘一次， 在性能和持久化方面做了很好的折中， 是受推荐的方式。# appendfsync no #完全依赖 OS 的写入， 一般为 30 秒左右一次， 性能最好但是持久化最没有保证， 不被推荐。#在日志重写时， 不进行命令追加操作， 而只是将其放在缓冲区里， 避免与命令的追加造成DISK IO 上的冲突。#设置为 yes 表示 rewrite 期间对新写操作不 fsync,暂时存在内存中,等 rewrite 完成后再写入， 默认为nono-appendfsync-on-rewrite no#当前 AOF 文件大小是上次日志重写得到 AOF 文件大小的二倍时， 自动启动新的日志重写过程。auto-aof-rewrite-percentage 100#当前 AOF 文件启动新的日志重写过程的最小值， 避免刚刚启动 Reids 时由于文件尺寸较小导致频繁的重写。auto-aof-rewrite-min-size 64mb]]></content>
      <categories>
        <category>redis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Redis哨兵机制(主备切换)]]></title>
    <url>%2Fdlh1234okok.github.io%2F2018%2F10%2F27%2FRedis%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[​ 访问网站时为了提高响应速度，从内存中获取热点数据比从数据库中获取要快很多，Redis是一个很好的Cache工具，大型网站的热点数据往往巨大，此时一台Redis服务器内存无法满足，需要集合多台Redis，但只有一台主机，其他都是从服务器，实现读写分离。 ​ 但是，万一主机宕机或中断了怎么办。 ​ Redis哨兵机制，对服务器进行监视，当主机‘挂’了的时候，它会从其他服务器中重新拥立一个新的主机，赋予可执行功能。当‘挂’掉的主机再重新启动后，就不再是主机了。 准备这里是单台服务器不同端口模拟3台服务器（1主2从） 节点准备127.0.0.1 6379（master-主节点） 127.0.0.1 6380（slave-从节点1） 127.0.0.1 6381（slave-从节点2） 主节点redis.conf配置设置端口 ， daemonize,密码， 连接主节点密码， requirepass 禁用 bind 等 基本配置 从节点redis.conf配置从节点配置和主节点基本类似，相比多一个配置 sentinel.conf哨兵文件配置 ​ 所有哨兵起先监视主机端口 ​ 为了方便快速看到效果，设置哨兵执行时效 测试开启所有三个服务和所有哨兵 将主服务kill掉 结果发现端口号为6381的从服务成功谋朝篡位为主服务 再次启动原本为主服务的6379 只能乖乖当6381的奴隶了吧~ 这里的一切均为本机127.0.0.1测试，如果需要连接局域网，可以改为本机ip地址]]></content>
      <categories>
        <category>redis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Redis搭建主从复用-读写分离]]></title>
    <url>%2Fdlh1234okok.github.io%2F2018%2F10%2F27%2FRedis%E6%90%AD%E5%BB%BA%E4%B8%BB%E4%BB%8E%E5%A4%8D%E7%94%A8-%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[​ Redis 支持主从复用。 数据可以从主服务器向任意数量的从服务器上同步， 同步使用的是发布/订阅机制。 Mater Slave 的模式， 从 Slave 向 Master 发起 SYNC 命令。可以是 1 Master 多 Slave， 可以分层， Slave 下可以再接 Slave， 可扩展成树状结构。因为没有两台电脑， 所以只能在一台机器上搭建两个 Redis 服务端。这里使用单机来模拟 redis 主从服务器 ， 实现读写分离配置 。 ​ 由于之前redis5.0版本配置文件有些不同，选择了降低版本使用了4.0.9版本 准备将编译后的redis主文件夹复制两份，一份为master（主），一份slave（从），复制的命令为 1cp -rf redis-4.0.9 redis-4.0.9-slave ​ 我们主要操作master和slave 修改主服务器配置进入master目录，vim 编辑 redis.conf文件 修改完成后：wq保存并退出 修改从服务器配置 添加设置作为谁的从服务器 启动服务器先启动主服务master，到src目录下 1./redis-server ../redis.conf &amp; ---以配置文件启动 ‘&amp;’---在后台运行 然后启动从服务slave 启动客户端1./redis-cli 从服务器需要以指定端口启动 1./redis-cli -p 6380 启动后输入info replication查看当前服务器状态 主服务器 从服务器 ​ 看到这些信息基本配置好了，接下来进行测试 测试主服务器 可读可写 ，我们添加一条数据，测试从服务器是否能读到 从服务器只有可读权限，关注它能否读取到主服务刚才写入的数据 测试发现无法写入，可以读取主服务写入的数据 ，成功。 下一章是配置哨兵机制~]]></content>
      <categories>
        <category>redis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[redis(2)-五种数据类型]]></title>
    <url>%2Fdlh1234okok.github.io%2F2018%2F10%2F27%2Fredis-2%2F</url>
    <content type="text"><![CDATA[key 相关指令​ exists key 检测指定 key 是否存在， 返回 1 表示存在， 0 不存在​ del key1 key2 …… keyN 删除给定 key,返回删除 key 的数目， 0 表示给定 key 都不存在​ type key 返回给定 key 值的类型。 返回 none 表示 key 不存在,string 字符类型， list 链表类型 set 无序集合类型……​ keys pattern 返回匹配指定模式的所有 key​ randomkey 返回从当前数据库中随机选择的一个 key,如果当前数据库是空的， 返回空串​ rename oldkey newkey 重命名一个 key,如果 newkey 存在， 将会被覆盖， 返回1 表示成功，0 失败。 可能是 oldkey 不存在或者和 newkey 相同。​ renamenx oldkey newkey 同上， 但是如果 newkey 存在返回失败。​ expire key seconds 为 key 指定过期时间， 单位是秒。 返回 1 成功， 0 表示key 已经设置超过过期时间或者不存在。​ ttl key 返回设置过过期时间 key 的剩余过期秒数。 -1 表示 key 不存在或者未设置过期时间。​ select db-index 通过索引选择数据库， 默认连接的数据库是 0,默认数据库数是16 个。 返回 1表示成功， 0 失败。​ move key db-index 将 key 从当前数据库移动到指定数据库。 返回 1 表示成功。0 表示 key不存在或者已经在指定数据库中。 五种基本数据类型redis 提供五种数据类型： string,hash,list,set 及sorted set String 类型string 是最基本的类型， 而且 string 类型是二进制安全的。 意思是 redis 的string 可以包含任何数据。 比如 jpg 图片或者序列化的对象。 从内部实现来看其实string 可以看作 byte 组， 最大上限是 1G 字节。 1G=1024MB string 类型数据操作指令简介​ set key value 设置 key 对应 string 类型的值， 返回 1 表示成功， 0 失败。​ setnx key value 如果 key 不存在， 设置 key 对应 string 类型的值。 如果key 已经存在， 返回 0。​ get key 获取 key 对应的 string 值,如果 key 不存在返回 nil​ getset key value 先获取 key 的值，再设置 key 的值。如果 key 不存在返回 nil。​ mget key1 key2 ……keyN 一次获取多个 key 的值， 如果对应 key 不存在，则对应返回 nil。​ mset key1 value1 ……keyN valueN 一次设置多个 key 的值， 成功返回 1表示所有的值都设置了， 失败返回0 表示没有任何值被设置。​ msetnx key1 value1 ……keyN valueN 一次设置多个 key 的值， 但是不会覆盖已经存在的 key ​ incr key 对 key 的值做++操作， 并返回新的值。 注意 incr 一个不是 int 的value 会返回错误， incr 一个不存在的 key， 则设置 key 值为 1。​ decr key 对 key 的值做–操作， decr 一个不存在 key， 则设置 key 值为-1。**​ incrby key integer 对 key 加上指定值 ， key 不存在时候会设置 key， 并认为原来的 value 是 0。​ decrby** key integer 对 key 减去指定值。 decrby 完全是为了可读性， 我们完全可以通过 incrby 一个负值来实现同样效果， 反之一样 应用场景​ String 是最常用的一种数据类型， 普通的 key/value 存储都可以归为此类， value 其实不仅是 String,也可以是数字： 比如想知道什么时候封锁一个 IP 地址(访问超过几次)。INCRBY 命令让这些变得很容易， 通过原子递增保持计数。 Hash 类型Hash 类型数据操作指令​ hset key field value 设置 hash field 为指定值， 如果 key 不存在， 则创建​ hget key field 获取指定的 hash field。​ hmget key filed1….fieldN 获取全部指定的 hash filed。​ hmset key filed1 value1 ……filedN valueN 同时设置hash的多个 field。​ hincrby key field integer 将指定的 hash filed 加上指定值。 成功返回 hash filed 变更后的值。​ hexists key field 检测指定 field 是否存在。​ hdel key field 删除指定的 hash field。​ hlen key 返回指定 hash 的 field 数量​ hkeys key 返回 hash 的所有 field。​ hvals key 返回 hash 的所有 value。​ hgetall key 返回 hash 的所有 filed 和 value。 应用场景​ 我们简单举个实例来描述下 Hash 的应用场景， 比如我们要存储一个用户信息对象数据， 包含以下信息：用户 ID， 为查找的 key，存储的 value 用户对象包含姓名 name， 年龄 age， 生日 birthday 等信息，如果用普通的 key/value 结构来存储， 主要有以下 2 种存储方式：​ 第一种方式将用户ID作为查找key,把其他信息封装成一个对象以序列化的方式存储，如： set u001 “李三,18,20010101” 这种方式的缺点是， 增加了序列化/反序列化的开销， 并且在需要修改其中一项信息时， 需要把整个对象取回， 并且修改操作需要对并发进行保护， 引入 CAS 等复杂问题。​ 第二种方法是这个用户信息对象有多少成员就存成多少个 key-value 对儿， 用用户 ID+对应属性的名称作为唯一标识来取得对应属性的值，如： mset user:001:name “李三” user:001:age 18 user:001:birthday “20010101”虽然省去了序列化开销和并发问题， 但是用户 ID 为重复存储， 如果存在大量这样的数据， 内存浪费还是非常可观的。那么 Redis 提供的 Hash 很好的解决了这个问题， Redis 的 Hash 实际是内部存储的Value 为一个 HashMap，并提供了直接存取这个 Map 成员的接口，如： hmset user:001 name “李三” age 18 birthday “20010101” 也就是说， Key 仍然是用户 ID,value 是一个 Map， 这个 Map 的 key 是成员的属性名， value 是属性值，这样对数据的修改和存取都可以直接通过其内部 Map 的 Key(Redis 里称内部 Map 的 key 为 field), 也就是通过key(用户 ID) + field(属性标签) 操作对应属性数据了， 既不需要重复存储数据， 也不会带来序列化和并发修改控制的问题。 很好的解决了问题。这里同时需要注意， Redis 提供了接口(hgetall)可以直接取到全部的属性数据,但是如果内部 Map 的成员很多， 那么涉及到遍历整个内部 Map 的操作， 由于 Redis 单线程模型的缘故， 这个遍历操作可能会比较耗时， 而另其它客户端的请求完全不响应， 这点需要格外注意。 实现方式：​ 上面已经说到 Redis Hash 对应 Value 内部实际就是一个 HashMap， 实际这里会有2 种不同实现， 这个 Hash的成员比较少时 Redis 为了节省内存会采用类似一维数组的方式来紧凑存储， 而不会采用真正的 HashMap 结构， 对应的 value redisObject 的encoding 为 zipmap,当成员数量增大时会自动转成真正的 HashMap。 List 类型List 类型数据操作指令简介​ lpush key string 在 key 对应 list 的头部添加字符串元素， 返回 1 表示成功， 0表示 key 存在且不是 list 类型。​ rpush key string 在 key 对应 list 的尾部添加字符串元素。​ llen key 返回 key 对应 list 的长度， 如果 key 不存在返回 0， 如果 key 对应类型不是 list 返回错误。​ lrange key start end 返回指定区间内的元素， 下标从 0 开始， 负值表示从后面计算， -1 表示倒数第一个元素 ， key 不存在返回空列表。​ ltrim key start end 截取 list 指定区间内元素， 成功返回 1， key 不存在返回错误。​ lset key indexvalue 设置 list 中指定下标的元素值， 成功返回 1， key 或者下标不存在返回错误。​ lrem key count value 从 List 的头部 （ count 正数） 或尾部 （ count 负数）删除一定数量 （ count） 匹配 value 的元素， 返回删除的元素数量。 count 为 0时候删除全部。​ lpop key 从 list 的头部删除并返回删除元素。 如果 key 对应 list 不存在或者是空返回 nil， 如果 key 对应值不是 list 返回错误。​ rpop key 从 list 的尾部删除并返回删除元素。​ blpop key1 ……keyN timeout 从左到右扫描， 返回对第一个非空 list 进行lpop 操作并返回， 比如 blpop list1 list2 list3 0 ,如果 list 不存在list2,list3 都是非空则对 list2 做 lpop 并返回从 list2 中删除的元素。 如果所有的 list 都是空或不存在， 则会阻塞 timeout 秒， timeout 为 0 表示一直阻塞。当阻塞时， 如果有 client 对 key1…keyN 中的任意 key 进行 push 操作， 则第一在这个 key 上被阻塞的 client 会立即返回。 如果超时发生， 则返回 nil。 有点像unix 的 select 或者 poll。 ​ brpop 同 blpop， 一个是从头部删除一个是从尾部删除 应用场景​ Redis list 的应用场景非常多， 也是 Redis 最重要的数据结构之一。​ 我们可以轻松地实现最新消息排行等功能。​ Lists 的另一个应用就是队列， 可以利用 Lists 的 PUSH 操作， 将任务存在 List 中，然后工作线程再用 POP 操作将任务取出进行执行。 实现方式：​ Redis list 的实现为一个双向链表， 即可以支持反向查找和遍历， 更方便操作， 不过带来了部分额外的内存开销， Redis 内部的很多实现， 包括发送缓冲队列等也都是用的这个数据结构。 Set 类型​ 是无序集合， 最大可以包含(2 的 32 次方-1)个元素。 set 的是通过 hashtable 实现的， 所以添加， 删除， 查找的复杂度都是 O(1)。 hash table 会随着添加或者删除自动的调整大小。 需要注意的是调整 hashtable 大小时候需要同步（获取写锁）会阻塞其他读写操作。 可能不久后就会改用跳表（ skip list） 来实现。 跳表已经在 sortedsets 中使用了。 关于 set 集合类型除了基本的添加删除操作， 其它有用的操作还包含集合的取并集(union)， 交集(intersection)， 差集(difference)。通过这些操作可以很容易的实现 SNS 中的好友推荐和 blog 的 tag 功能 set 类型数据操作指令简介​ sadd key member 添加一个 string 元素到 key 对应 set 集合中， 成功返回 1,如果元素以及在集合中则返回 0， key 对应的 set 不存在则返回错误。​ srem key member 从 key 对应 set 中移除指定元素， 成功返回 1， 如果 member在集合中不存在或者 key 不存在返回 0， 如果 key 对应的不是 set 类型的值返回错误。​ spop key 删除并返回 key 对应 set 中随机的一个元素,如果 set 是空或者 key不存在返回 nil。​ srandmember key 同 spop， 随机取 set 中的一个元素， 但是不删除元素。​ smove srckey dstkey member 从 srckey 对应 set 中移除 member 并添加到dstkey 对应 set 中， 整个操作是原子的。 成功返回 1,如果 member 在 srckey 中不存在返回 0， 如果 key 不是 set 类型返回错误。​ Scard key 返回 set 的元素个数， 如果 set 是空或者 key 不存在返回 0。​ sismember key member 判断 member 是否在 set 中， 存在返回 1， 0 表示不存在或者 key 不存在。​ sinter key1 key2 …… keyN 返回所有给定 key 的交集。​ sinterstore dstkey key1 ……. keyN 返回所有给定 key 的交集， 并保存交集存到 dstkey 下。​ sunion key1 key2 …… keyN 返回所有给定 key 的并集。​ sunionstore dstkey key1 ……keyN 返回所有给定 key 的并集， 并保存并集到 dstkey 下。​ sdiff key1 key2 ……keyN 返回所有给定 key 的差集。​ sdiffstore dstkey key1 ……keyN 返回所有给定 key 的差集， 并保存差集到 dstkey 下。​ smembers key 返回 key 对应 set 的所有元素， 结果是无序的。 应用场景​ Redis set 对外提供的功能与 list 类似是一个列表的功能， 特殊之处在于 set 是可以自动排重的， 当你需要存储一个列表数据， 又不希望出现重复数据时， set 是一个很好的选择， 并且 set 提供了判断某个成员是否在一个 set 集合内的重要接口， 这个也是 list所不能提供的。​ 比如在微博应用中， 每个人的好友存在一个集合（set） 中， 这样求两个人的共同好友的操作， 可能就只需要用求交集命令即可。 （新浪微博关注共同好友） ​ Redis 还为集合提供了求交集、 并集、 差集等操作。实现方式：​ set 的内部实现是一个 value 永远为 null 的 HashMap， 实际就是通过计算 hash的方式来快速排重的， 这也是 set 能提供判断一个成员是否在集合内的原因。 Sorted Set 类型​ Sorted Set 是有序集合， 它在 set 的基础上增加了一个顺序属性， 这一属性在添加修改元素的时候可以指定， 每次指定后， 会自动重新按新的值调整顺序。 可以理解了有两列的 mysql 表， 一列存 value， 一列存顺序。 操作中 key 理解为sorted set 的名字， 最多包含 2&gt;32-1 个元素 。 Sorted Set 类型数据操作指令简介​ zadd key score member 添加元素到集合， 元素在集合中存在则更新对应 score。​ zrem key member 删除指定元素， 1 表示成功， 如果元素不存在返回 0。​ zincrby key incrmember 增加对应 member 的 score 值， 然后移动元素并保持 skip list 保持有序。 返回更新后的 score 值。​ zrank key member 返回指定元素在集合中的排名（下标）， 集合中元素是按 score从小到大排序的。​ zrevrankkey member 同上,但是集合中元素是按 score 从大到小排序。​ zrange key start end 类似 lrange 操作从集合中去指定区间的元素。 返回的是有序结果​ zrevrange key start end 同上， 返回结果是按 score 逆序的。​ zrangebyscore key min max 返回集合中 score 在给定区间的元素。​ zcount key min max 返回集合中 score 在给定区间的数量。​ zcard key 返回集合中元素个数。​ zscore key element 返回给定元素对应的 score 应用场景​ 以某个条件为权重， 比如按顶的次数排序.ZREVRANGE 命令可以用来按照得分来获取前 100 名的用户， ZRANK 可以用来获取用户排名， 非常直接而且操作容易。​ Redis sorted set 的使用场景与 set 类似， 区别是 set 不是自动有序的， 而 sorted set 可以通过用户额外提供一个优先级(score)的参数来为成员排序， 并且是插入有序的，即自动排序。​ 比如:twitter 的 public timeline 可以以发表时间作为 score 来存储， 这样获取时就是自动按时间排好序的。​ 比如:全班同学成绩的 SortedSets， value 可以是同学的学号， 而 score 就可以是其考试得分， 这样数据插入集合的， 就已经进行了天然的排序。​ 比如网易云音乐排行榜实现；​ 另外还可以用 Sorted Sets 来做带权重的队列， 比如普通消息的 score 为 1， 重要消息的 score 为 2， 然后工作线程可以选择按 score 的倒序来获取工作任务。 让重要的任务优先执行。需要精准设定过期时间的应用​ 比如你可以把上面说到的 sorted set 的 score 值设置成过期时间的时间戳， 那么就可以简单地通过过期时间排序， 定时清除过期数据了， 不仅是清除 Redis 中的过期数据，你完全可以把 Redis 里这个过期时间当成是对数据库中数据的索引， 用 Redis 来找出哪些数据需要过期删除， 然后再精准地从数据库中删除相应的记录。]]></content>
      <categories>
        <category>redis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[redis简介和安装]]></title>
    <url>%2Fdlh1234okok.github.io%2F2018%2F10%2F25%2Fredis-1%2F</url>
    <content type="text"><![CDATA[介绍​ Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。 ——http://www.redis.cn/ 小结： Redis 是把数据存放在内存当中， 所以它的运行速度会非常快 Redis 具有多种数据存储结构 Redis 具有持久化的功能 Redis 上的数据可以设置过期 Redis 支持集群， 而且可以自动切换 跨平台 支持多种语言客户端 Redis 用途： ​ 缓存（StackOverFlow）， 数据库(微博)， 消息中间件（队列， 微博） Redis安装环境：centerOS 6.7 虚拟机 redis版本：5.0 1、通过xshell建立连接，使用wget命令下载对应的节点资源 wget http://download.redis.io/releases/redis-5.0.0.tar.gz ​ 或者去官网下载，使用xftp导入 2、安装gcc环境 ​ yum install gcc 3、解压redis压缩文件 ​ tar zxf redis-5.0.0.tar.gz 4、进入解压后的文件夹 ​ make -编译 ​ 完成~ 启动redis服务进入src目录 ./redis-server &amp; 在后面加上&amp;在启动服务后可以继续别的操作，否则以当前窗口启动无法进行其他操作。 出现以上界面表示服务启动成功 启动客户端 ./redis-cli 启动成功就可以在里面愉快地敲命令了！]]></content>
      <categories>
        <category>redis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Crm项目-权限模块]]></title>
    <url>%2Fdlh1234okok.github.io%2F2018%2F10%2F22%2FCrm%E9%A1%B9%E7%9B%AE%E6%9D%83%E9%99%90%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[​ 在这个项目中权限管理模块分为用户信息管理、角色管理、资源管理三个方面对不同用户的权限进行管理。 ​ 由于每个用户可以有多个角色，每个角色有多个模块权限，处理这些多对多的关系，建立了两张中间表，其中用户和角色之间的中间表，角色和权限的中间表，所以这里权限管理总共有五张表： ​ 用户表：t_user 、 角色表：t_role 、 用户和角色的关系中间表：t_user_role ​ 模块表：t_module 、角色和模块的关系中间表：t_permission 用户信息管理 ​ 这里主要管理用户和用户的角色分配，通过中间表t_user_role中的userId和roleId对另外两张表关联 ​ 其中需要将多行数据显示到一行，使用了mysql的group_concat语法 角色管理 ​ 最主要的是关联权限，这里用了zTree插件建立了一棵权限树 ​ ​ 通过t_permission中间表中的roleId和moduleId连接t_role和t_module两张表之间的关系 ​ 资源管理 ​ 通过t_permission表和t_module表中的权限码关联 ​ 这个项目中权限码的设定是进行权限管理的关键 权限管理如何进行管理 ​ 前台管理：freemake-所见即有权限 ​ 思路： ​ 1、登录时根据用户id查询两张中间表中角色id相同的权限码（该用户拥有的权限码），并将结果存到session作用域中 ​ 2、前台模版引擎判断作用域中权限码是否存在和对应权限码显示 1234567891011121314&lt;#if permissions??&gt; &lt;!--判断作用域存在的话才展示以下信息--&gt; &lt;#if permissions?seq_contains("10")&gt; &lt;!--判断作用域中包含才展示以下信息--&gt; &lt;div title="营销管理" data-options="selected:true,iconCls:'icon-yxgl'" style="padding: 10px"&gt; &lt;#if permissions?seq_contains("1010")&gt; &lt;a href="javascript:openTab('营销机会管理','saleChance/index/1','icon-yxjhgl')" class="easyui-linkbutton" data-options="plain:true,iconCls:'icon-yxjhgl'" style="width: 150px"&gt;营销机会管理&lt;/a&gt; &lt;/#if&gt; &lt;#if permissions?seq_contains("1020")&gt; &lt;a href="javascript:openTab('客户开发计划','saleChance/index/2','icon-khkfjh')" class="easyui-linkbutton" data-options="plain:true,iconCls:'icon-khkfjh'" style="width: 150px"&gt;客户开发计划&lt;/a&gt; &lt;/#if&gt; &lt;/div&gt; &lt;/#if&gt; &lt;/#if&gt; ​ ​ 后台管理：通过spring-aop+自定义注解进行统一管理 ​ 思路： ​ 1、自定义注解 ​ 2、配置切面，对标记有该注解的注解中的值和session作用域中的内容进行比较判断，对不包含访问该资源所需权限码的行为进行拦截。 1234567891011121314151617181920212223242526272829@Component@Aspectpublic class PermissionAdaptor &#123; @Pointcut("@annotation(com.shsxt.crm.annotation.RequestPermission)") public void cut() &#123; &#125; @Around("cut()") public Object around(ProceedingJoinPoint pjp) throws Throwable &#123; // 得到方法签名 MethodSignature signature = (MethodSignature) pjp.getSignature(); // 通过方法签名拿到方法 Method method = signature.getMethod(); // 通过方法拿到注解 RequestPermission requestPermission = method.getAnnotation(RequestPermission.class); // 拿到注解中的value String aclValue = requestPermission.aclValue(); // 通过spring线程的上下文获取request对象（也可以直接注入httpsession，我只是做测试） ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); HttpServletRequest request = requestAttributes.getRequest(); // 通过request对象拿到session中的内容 List&lt;String&gt; permission = (List&lt;String&gt;) request.getSession().getAttribute(CrmConstant.USER_PERMISSIONS); // 判断集合中是否包含ACLValue拦截 AssertUtil.isTrue(CollectionUtils.isEmpty(permission) || !permission.contains(aclValue), "没有权限"); return pjp.proceed(); &#125;&#125;]]></content>
      <categories>
        <category>项目经验</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC学习(8)-异常处理]]></title>
    <url>%2Fdlh1234okok.github.io%2F2018%2F10%2F12%2FSpringMVC%E5%AD%A6%E4%B9%A0-8%2F</url>
    <content type="text"><![CDATA[SpringMVC处理全局异常1、使用SpringMVC提供的简单异常处理器SimpleMappingExceptionResolver 2、实现Spring的异常处理接口HandlerExceptionResolver定义自己的异常处理器 3、使用@ExceptionHandler 注解实现异常处理 全局异常处理方式一配置SimpleMappingExceptionResolver对象（配置servlet-context配置文件） 123456789&lt;bean class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver"&gt; &lt;property name="defaultErrorView" value="error"&gt;&lt;/property&gt; &lt;property name="exceptionAttribute" value="ex"&gt;&lt;/property&gt; &lt;property name="exceptionMappings"&gt; &lt;props&gt; &lt;prop key="com.shsxt.exception.ParamException"&gt;param&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; ​ 优点：集成简单，有良好的扩展性，对已有代码没有入侵性等 ​ 缺点：该方法仅能获取到异常信息，若在出现异常时，对需要获取除异常以外的数据的情况不适用。 全局异常处理方式二定义自己的异常处理器，实现HandlerExceptionResolver接口 12345678910111213141516171819202122232425@Component // 在需要使用时只需要加上这个注解交给spring管理即可public class MyExceptionHandler implements HandlerExceptionResolver &#123; @Override public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; System.out.println("============================="); System.out.println("======MyExceptionHandler====="); System.out.println("============================="); ModelAndView mv = new ModelAndView(); // 当发生参数异常时 instanceof--判断左边对象是否是右边类的实例 if (ex instanceof ParamException)&#123; // 将异常转为参数异常 ParamException paramException = (ParamException) ex; // 设置视图页面 mv.setViewName("param"); // 设置模型数据 mv.addObject("ex",ex); return mv; &#125; mv.setViewName("error"); mv.addObject("ex",ex); return mv; &#125;&#125; ​ 相比于配置SimpleMappingExceptionResolver对象方式，实现接口的方式能在异常处理时获取出现异常的对象，能提供更详细的异常处理信息 全局异常处理方式三定义异常处理器，使用@ExceptionHandler注解，页面处理器继承异常处理器 1234567891011public class ExceptionController &#123; @ExceptionHandler public String ex(HttpServletRequest request, Exception e)&#123; request.setAttribute("ex",e); if (e instanceof ParamException)&#123; return "param"; &#125; return "error"; &#125;&#125; 123456789101112@Controller@RequestMapping("index")public class IndexController extends ExceptionController&#123; /*参数异常*/ @RequestMapping("test01") public String test01() &#123; if (true)&#123; throw new ParamException("参数异常"); &#125; return "index"; &#125;&#125; ​ 该方法需要修改已有代码，且受限于java单继承的局限性，在获取异常时不能获取除异常之外的数据 未捕获异常的处理​ 对于Unchecked Exception而言，由于代码不强制捕获，往往被忽略，如果运行期产生了Unchecked Exception，而代码中又没有进行相应的捕获和处理，则我们可能不得不面对尴尬的404、500……等服务器内部错误提示页面。​ 我们需要一个全面而有效的异常处理机制。目前大多数服务器也都支持在Web.xml中通过(Websphere/Weblogic)或者(Tomcat)节点配置特定异常情况的显示页面。修改 web.xml 文件，增加以下内容： 12345678910111213&lt;!-- 出错页面定义 --&gt; &lt;error-page&gt; &lt;exception-type&gt;java.lang.Throwable&lt;/exception-type&gt; &lt;location&gt;/500.jsp&lt;/location&gt; &lt;/error-page&gt; &lt;error-page&gt; &lt;error-code&gt;500&lt;/error-code&gt; &lt;location&gt;/500.jsp&lt;/location&gt; &lt;/error-page&gt; &lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/404.jsp&lt;/location&gt; &lt;/error-page&gt;]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC学习(7)-SpringMVC实现RestFul服务]]></title>
    <url>%2Fdlh1234okok.github.io%2F2018%2F10%2F12%2FSpringMVC%E5%AD%A6%E4%B9%A0-7%2F</url>
    <content type="text"><![CDATA[​ Restful 风格的 API 是一种软件架构风格， 设计风格而不是标准， 只是提供了一组设计原则和约束条件。 它主要用于客户端和服务器交互类的软件。 基于这个风格设计的软件可以更简洁， 更有层次， 更易于实现缓存等机制。​ 在 Restful 风格中， 用户请求的 url 使用同一个 url 而用请求方式： get， post，delete， put…等方式对请求的处理方法进行区分， 这样可以在前后台分离式的开发中使得前端开发人员不会对请求的资源地址产生混淆和大量的检查方法名的麻烦， 形成一个统一的接口。 在 Restful 风格中， 现有规定如下：​ GET（ SELECT） ： 从服务器查询， 可以在服务器通过请求的参数区分查询的方式。​ POST（ CREATE） ： 在服务器端新建一个资源， 调用 insert 操作。​ PUT（ UPDATE） ： 在服务器端更新资源， 调用 update 操作。​ PATCH（ UPDATE） ： 在服务器端更新资源（ 客户端提供改变的属性） 。 (目前jdk7 未实现， tomcat7 不支持)。​ DELETE（ DELETE） ： 从服务器端删除资源， 调用 delete 语句。 Spring Mvc 中对 rest 的支持案例：​ 如何在 java 构造没有扩展名的 RESTful url,如 /forms/1 SpringMvc Restful 风格 url 配置实现​ springmvc 的 resturl是通过@RequestMapping 及@PathVariable annotation提供的,通过如@RequestMapping(value=”/blog /{id}”,method=RequestMethod.DELETE)即可处理/blog/1 的 delete 请求. GET请求配置1234567891011121314151617/** * restful--&gt;get 请求 执行查询操作 * @param id * @return */ @RequestMapping(value="queryAccountById02/&#123;id&#125;",method= RequestMethod.GET,produces= MediaType.APPLICATION_JSON_UTF8_VALUE) @ResponseBody public MessageModel queryAccountById(@PathVariable Integer id)&#123; MessageModel messageModel=new MessageModel(); if(null==id)&#123; messageModel.setCode(300); messageModel.setMsg("参数非法!"); return messageModel; &#125; messageModel.setResult(accountService.queryById(id)); return messageModel; &#125; POST请求配置12345678910111213141516171819202122/* restful--&gt;post 请求执行添加操作 * @param id * @param aname * @return */@RequestMapping(value = "saveAccount", method = RequestMethod.POST, produces = MediaType.APPLICATION_JSON_UTF8_VALUE)@ResponseBodypublic MessageModel queryAccountById04(@RequestBody Account account) &#123; MessageModel messageModel = new MessageModel(); try &#123; accountService.saveOrUpdateAccount(account); &#125; catch (ParamsException e) &#123; e.printStackTrace(); messageModel.setCode(e.getErrorCode()); messageModel.setMsg(e.getErrorMsg()); &#125; catch (Exception e) &#123; e.printStackTrace(); messageModel.setCode(300); messageModel.setMsg("操作失败!"); &#125; return messageModel;&#125; Put请求配置12345678910111213141516171819202122/* restful--&gt;put 请求执行更新操作 * @param id * @param account * @return */@RequestMapping(value = "update/&#123;id&#125;", method = RequestMethod.PUT, produces = MediaType.APPLICATION_JSON_UTF8_VALUE)@ResponseBodypublic MessageModel queryAccountById04(@PathVariable Integer id, @RequestBody Account account) &#123; MessageModel messageModel = new MessageModel(); try &#123; accountService.saveOrUpdateAccount(account); &#125; catch (ParamsException e) &#123; e.printStackTrace(); messageModel.setCode(e.getErrorCode()); messageModel.setMsg(e.getErrorMsg()); &#125; catch (Exception e) &#123; e.printStackTrace(); messageModel.setCode(300); messageModel.setMsg("操作失败!"); &#125; return messageModel;&#125; Delete请求配置12345678910111213141516171819202122/* restful--&gt;delete 请求 执行删除操作 * @param id * @return */@RequestMapping(value = "deleteAccountById/&#123;id&#125;", method = RequestMethod .DELETE, produces = MediaType.APPLICATION_JSON_UTF8_VALUE)@ResponseBodypublic MessageModel queryAccountById05(@PathVariable Integer id) &#123; MessageModel messageModel = new MessageModel(); try &#123; accountService.deleteAccountById(id); &#125; catch (ParamsException e) &#123; e.printStackTrace(); messageModel.setCode(e.getErrorCode()); messageModel.setMsg(e.getErrorMsg()); &#125; catch (Exception e) &#123; e.printStackTrace(); messageModel.setCode(300); messageModel.setMsg("操作失败!"); &#125; return messageModel;&#125;]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC学习(6)-文件上传-SSM整合]]></title>
    <url>%2Fdlh1234okok.github.io%2F2018%2F10%2F11%2FSpringMVC%E5%AD%A6%E4%B9%A0-6%2F</url>
    <content type="text"><![CDATA[步骤添加依赖12345&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt; 配置servlet-context.xml123456789&lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;property name="maxUploadSize"&gt; &lt;value&gt;104857600&lt;/value&gt; &lt;/property&gt; &lt;property name="maxInMemorySize"&gt; &lt;value&gt;4096&lt;/value&gt; &lt;/property&gt;&lt;/bean&gt; 实现代码1234567891011121314151617181920212223242526@Controllerpublic class FileController &#123; @RequestMapping("file") public String fileUp(HttpServletRequest request, Model model)&#123; MultipartHttpServletRequest multRequest = (MultipartHttpServletRequest) request; MultipartFile file = multRequest.getFile("file"); if (null!=file &amp;&amp; !file.isEmpty())&#123; String path = request.getSession().getServletContext().getRealPath("upload"); String fileName = file.getOriginalFilename(); try &#123; file.transferTo(new File(path,fileName)); model.addAttribute("msg","上传成功"); &#125; catch (IOException e) &#123; e.printStackTrace(); model.addAttribute("msg","上传失败"); &#125; &#125; return "success"; &#125; @RequestMapping("fileUp") public String file()&#123; return "file"; &#125;&#125; 前台页面代码1234567891011&lt;html&gt;&lt;head&gt; &lt;title&gt;文件上传&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="file" method="post" enctype="multipart/form-data"&gt; &lt;input type="file" name="file"&gt; &lt;input type="submit"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 123456789&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;结果&lt;/title&gt;&lt;/head&gt;&lt;body&gt;操作：$&#123;msg&#125;&lt;/body&gt;&lt;/html&gt; 测试选择一个文件 提交 此时上传的文件已经在webapp/upload目录下 关于SSM整合 整合完成的项目我已经放在GitHub上 https://github.com/dlh1234okok/SSM]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC学习(5)-拦截器]]></title>
    <url>%2Fdlh1234okok.github.io%2F2018%2F10%2F11%2FSpringMVC%E5%AD%A6%E4%B9%A0-5%2F</url>
    <content type="text"><![CDATA[​ SpringMVC 中的 Interceptor 拦截器也是相当重要和相当有用的，它的主要作用是拦截用户的请求并进行相应的处理。比如通过它来进行权限验证，或者是来判断用户是否登陆等操作。 对于 springmvc 拦截器的定义方式有两种方式 实现接口： org.springframework.web.servlet.HandlerInterceptor 继承适配器 org.springframework.web.servlet.handler.HandlerInterceptorAdapter 实现接口1234567891011121314151617181920212223public class MyInterceptor implements HandlerInterceptor &#123; // 请求方法执行前执行 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println("method before..."); // 请求地址 System.out.println(handler); // true代表放行，false拦截 return true; &#125; // 请求方法执行后执行 @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println("method after..."); &#125; // 视图生成后执行 @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println("view after..."); &#125;&#125; 继承HandlerInterceptorAdapter123456789101112public class MyInterceptor2 extends HandlerInterceptorAdapter &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println("before preHandle..."); return true; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println("after completion"); &#125;&#125; 拦截器的配置全局拦截123&lt;mvc:interceptors&gt; &lt;bean class="com.shsxt.interceptor.MyInterceptor"/&gt;&lt;/mvc:interceptors&gt; 部分拦截（拦截指定请求）123456&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/user/*"/&gt; &lt;bean class="com.shsxt.interceptor.MyInterceptor"/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 简单的登录拦截拦截器类代码123456789101112131415161718public class LoginInterceptor extends HandlerInterceptorAdapter &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; String uri = request.getRequestURI(); if (uri.indexOf("login") != -1) &#123; return true; &#125; else &#123; // 判断Session是否存在（是否已登录） User user = (User) request.getSession().getAttribute("user"); if (null != user) &#123; return true; &#125; else &#123; response.sendRedirect(request.getContextPath() + "/login.jsp"); return false; &#125; &#125; &#125;&#125; 配置文件配置123456&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/*/*"/&gt; &lt;bean class="com.shsxt.interceptor.LoginInterceptor"/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 还有一种方式： 1234567&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/*/*"/&gt; &lt;mvc:exclude-mapping path="/user/login"/&gt; &lt;bean class="com.shsxt.interceptor.LoginInterceptor2"/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 在这里已经放行了登录地址，所以拦截器代码不需要再获取请求地址判断。 登录代码12345678910111213@RequestMapping("login")public String login(User user, Model model, HttpSession session)&#123; final String USERNAME="zs"; final String USERPWD="123"; System.out.println(user.getUserName()+"+"+user.getUserPwd()); if (USERNAME.equals(user.getUserName()) &amp;&amp; USERPWD.equals(user.getUserPwd()))&#123; model.addAttribute("msg","登陆成功"); session.setAttribute("user",user); &#125;else&#123; model.addAttribute("msg","帐号或密码错误"); &#125; return "index";&#125; 效果初次重启了服务器，Session不存在，输入简易查询的路径 1http://localhost:8080/springmvc01/user/user01 被拦截重定向到登录界面了 当我们登录后再次进行查询 简易的登录拦截器就完成了。]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC学习(4)-requst,response和JSON格式]]></title>
    <url>%2Fdlh1234okok.github.io%2F2018%2F10%2F11%2FSpringMVC%E5%AD%A6%E4%B9%A0-4%2F</url>
    <content type="text"><![CDATA[JSON数据返回@ResponseBody​ 该注解用于将 Controller 的方法返回的对象，通过适当的 HttpMessageConverter转换为指定格式后，写入到 Response 对象的 body 数据区。​ 返回的数据不是 html 标签的页面，而是其他某种格式的数据时（如 json、xml 等）使用（通常用于 ajax 请求） @RequestBody​ 该注解用于读取 Request 请求的 body 部分数据，使用系统默认配置的HttpMessageConverter 进行解析，然后把相应的数据绑定到要返回的对象上 ,再把HttpMessageConverter 返回的对象数据绑定到 controller 中方法的参数上 步骤： 1、添加json依赖jar包 12345678910111213141516&lt;!-- 添加 json 依赖 jar 包 --&gt;&lt;dependency&gt;&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;&lt;artifactId&gt;jackson-core&lt;/artifactId&gt;&lt;version&gt;2.7.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;&lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;&lt;version&gt;2.7.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;&lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;&lt;version&gt;2.7.0&lt;/version&gt;&lt;/dependency&gt; 2、修改servlet-context.xml 添加json转换器配置 123456789&lt;!-- json 支持 --&gt;&lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"&gt;&lt;/bean&gt;&lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"&gt; &lt;property name="messageConverters"&gt; &lt;list&gt; &lt;bean class="org.springframework.http.converter.json.MappingJackson2HttpMessageConverter"/&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 在方法上定义@ResponseBody 123456789@RequestMapping("view01")@ResponseBodypublic User queryUser(Integer id)&#123; User user = new User(); user.setId(id); user.setUserName("zs"); user.setUserPwd("123"); return user;&#125; 查看结果： 获取request和response对象123456789@RequestMapping("user01")public String user01(HttpServletRequest request, HttpServletResponse response, HttpSession session)&#123; request.getParameter("request"); response.addCookie(new Cookie("cookie","a")); session.getAttribute("user"); return "hello";&#125;]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC学习(3)-请求转发和重定向]]></title>
    <url>%2Fdlh1234okok.github.io%2F2018%2F10%2F11%2FSpringMVC%E5%AD%A6%E4%B9%A0-3%2F</url>
    <content type="text"><![CDATA[区别1、请求转发是在服务端完成的，重定向是在客户端完成的 2、请求转发是一次请求，重定向是两次请求 3、请求转发地址栏不会发生变化，重定向地址栏会发生变化 4、请求转发速度快，重定向速度慢 5、请求转发只能在同一台服务器下完成，重定向能在不同服务器完成 请求转发转发到view页面 12345@RequestMapping("index08")public String index08()&#123; System.out.println("index08..."); return "hello";&#125; 转发到方法上 12345@RequestMapping("index07")public String index07()&#123; System.out.println("index07..."); return "forward:/index08";&#125; 重定向直接返回redirect+页面 12345678/** * 重定向1 * @return */@RequestMapping("index04")public String index04()&#123; return "redirect:v1.jsp";&#125; 返回ModelAndView对象 12345public ModelAndView index06()&#123; ModelAndView mv = new ModelAndView(); mv.setViewName("redirect:v1.jsp"); return mv;&#125; 重定向传递参数1234@RequestMapping("index04")public String index04()&#123; return "redirect:v1.jsp?a=1&amp;b=哈哈";&#125; 用这种方法传递中文参数会出现乱码。 解决乱码 12345678910/** * 重定向中文乱码问题 * @return */@RequestMapping("index05")public String index05(RedirectAttributes redirect)&#123; redirect.addAttribute("a",1); redirect.addAttribute("b","哈哈哈"); return "redirect:v1.jsp";&#125; 结果： 重定向方法二传递参数 12345678@RequestMapping("index06")public ModelAndView index06(RedirectAttributes attributes)&#123; ModelAndView mv = new ModelAndView(); attributes.addAttribute("a","哈哈哈"); attributes.addAttribute("b","aaa"); mv.setViewName("redirect:v1.jsp"); return mv;&#125; 结果： 也成功传递了参数并解决了中文乱码问题 重定向到controller1234@RequestMapping("index004")public String index004()&#123; return "redirect:/view/view01？id=1";&#125; view01： 1234567891011121314@Controller@RequestMapping("view")public class ViewController &#123; @RequestMapping("view01") @ResponseBody public User queryUser(Integer id)&#123; User user = new User(); user.setId(id); user.setUserName("zs"); user.setUserPwd("123"); return user; &#125;&#125; 结果： ​ 我们在重定向时传递了一个id为1的参数，重定向到view01方法上获取到了。 方法二： 1234567@RequestMapping("index006")public ModelAndView index006(RedirectAttributes attributes)&#123; ModelAndView mv = new ModelAndView(); attributes.addAttribute("id",2); mv.setViewName("redirect:/view/view01"); return mv;&#125; 结果：]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC学习(2)-参数绑定和Session]]></title>
    <url>%2Fdlh1234okok.github.io%2F2018%2F10%2F11%2FSpringMVC%E5%AD%A6%E4%B9%A0-2%2F</url>
    <content type="text"><![CDATA[参数绑定​ SpringMVC是处于控制层的框架，主要处理前台页面的请求和响应，在前台发起请求后，我们需要获取传过来的参数。参数绑定是请求参数到处理器功能处理方法的方法参数上的绑定，对于参数绑定SpringMVC处理的非常灵活。 简单数据类型值必须存在，不传可以通过默认值代替 1234567@RequestMapping("index") public void data1(@RequestParam(defaultValue="10",name="age")int age, @RequestParam(defaultValue="1",name="flag")boolean flag, @RequestParam(defaultValue="100",name="s")double s) &#123; System.err.println("age:"+age+":flag:"+flag+":s:"+s); &#125; 包装类型值可以为空 123456789/** * defaultValue：默认值 * name：指定前台传参的别名 */ @RequestMapping("hello13") public String hello06(@RequestParam(defaultValue = "1",name = "page") Integer pageNum, Integer pageSize)&#123; System.out.println(pageNum+"=="+pageSize); return "hello"; &#125; 数组类型12345678/** * 数组类型 */@RequestMapping("hello07")public String hello07(Integer[] ids)&#123; for(Integer id:ids) System.out.println(id); return "hello";&#125; 前台传递参数名相同时即为数组类型，如： 1http://localhost:8080/springmvc01/hello07?ids=1&amp;ids=2&amp;ids=3 PO类型12345@RequestMapping("hello08")public String hello08(User user)&#123; System.out.println(user); return "hello";&#125; 前台传参方式如： 1http://localhost/springmvc01/hello08?userName=zs&amp;userPwd=123 List类型此时实体类需要定义List属性 1private List&lt;Phone&gt; phones; 不能直接写在controller的方法中： 12345@RequestMapping("hello09")public String hello09(User user)&#123; System.out.println(user); return "hello";&#125; 前台传参方式（必须为post方式）： 12list:&lt;input type="text" name="phones[0].num"/&gt; &lt;input type="text" name="phones[1].num"/&gt; Set类型​ 因为Set集合无序的特点，绑定Set数据时，必须先在Set对象中add添加响应数量的模型对象。 12345private Set&lt;Phone&gt; phones = new HashSet&lt;&gt;();public User() &#123; phones.add(new Phone()); phones.add(new Phone());&#125; controller方法和前台传参方式和list一样。Set集合的优点在这里是不可重复。 Map类型在实体类中定义Map属性 1private Map&lt;String,Phone&gt; map = new HashMap&lt;&gt;(); controller方法： 123456789@RequestMapping("hello11")public String hello11(User user)&#123; Set&lt;Map.Entry&lt;String, Phone&gt;&gt; entrySet = user.getMap().entrySet(); for (Map.Entry&lt;String,Phone&gt; entry:entrySet)&#123; System.out.println(entry.getKey()); System.out.println(entry.getValue()); &#125; return "hello";&#125; 前台传参方式： 123map:&lt;input type="text" name="map['a'].num"/&gt; &lt;input type="text" name="map['b'].num"/&gt; &lt;input type="text" name="map['c'].num"/&gt; 自定义复合类型添加实体的引用 1private Phone phone; controller方法： 12345@RequestMapping("hello12")public String hello12(User2 user)&#123; System.out.println(user); return "hello";&#125; 前台传参方式： 1复合类型：&lt;input type="text" name="phone.num"/&gt; 获取Session级别存储的方式123456789101112131415161718192021222324252627282930313233343536/** * Session01 * @param session * @param userName * @return */@RequestMapping("index01")public String index01(HttpSession session,String userName)&#123; session.setAttribute("userName1",userName); return "index";&#125;/** * Session02 * @return * 这里前台取参的方式为$&#123;sessionScop.userName2&#125; */ @RequestMapping("index02")public ModelAndView index02(String userName)&#123; ModelAndView mv = new ModelAndView(); mv.addObject("userName2",userName); mv.setViewName("index"); return mv;&#125;/** * Session03 * @param request * @param userName * @return */@RequestMapping("index03")public String index03(HttpServletRequest request,String userName)&#123; request.getSession().setAttribute("userName3",userName); return "index";&#125;]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC学习(1)-简介和环境搭建]]></title>
    <url>%2Fdlh1234okok.github.io%2F2018%2F10%2F11%2FSpringMVC%E5%AD%A6%E4%B9%A0-1%2F</url>
    <content type="text"><![CDATA[什么叫MVC​ 模型-视图-控制器（MVC） 是一个众所周知的以设计界面应用程序为基础的设计思想。 它主要通过分离模型、 视图及控制器在应用程序中的角色将业务逻辑从界面中解耦。 通常， 模型负责封装应用程序数据在视图层展示。 视图仅仅只是展示这些数据， 不包含任何业务逻辑。 控制器负责接收来自用户的请求，并调用后台服务（service 或者 dao） 来处理业务逻辑。 处理后， 后台业务层可能会返回了一些数据在视图层展示。 控制器收集这些数据及准备模型在视图层展示。 MVC 模式的核心思想是将业务逻辑从界面中分离出来， 允许它们单独改变而不会相互影响。 SpringMVC是什么​ Spring MVC 是 Spring 家族中的一个 web 成员, 它是一种基于 Java 的实现了 Web MVC 设计思想的请求驱动类型的轻量级 Web 框架， 即使用了 MVC 架构模式的思想， 将 web 层进行职责解耦， 基于请求驱动指的就是使用请求-响应模型， 框架的目的就是帮助我们简化开发， Spring MVC 也是要简化我们日常Web 开发的。​ Spring MVC 是服务到工作者思想的实现。 前端控制器是DispatcherServlet； 应用控制器拆为处理器映射器(Handler Mapping)进行处理器管理和视图解析器(View Resolver)进行视图管理； 支持本地化/国际化（Locale） 解析及文件上传等； 提供了非常灵活的数据验证、 格式化和数据绑定机制； 提供了强大的约定大于配置（惯例优先原则） 的契约式编程支持。 环境搭建开发环境​ IDEA+JDK1.8+Maven+Jetty 添加依赖12345678910111213141516171819&lt;!-- spring web --&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework&lt;/groupId&gt;&lt;artifactId&gt;spring-web&lt;/artifactId&gt;&lt;version&gt;4.3.2.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- spring mvc --&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework&lt;/groupId&gt;&lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;&lt;version&gt;4.3.2.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- web servlet --&gt;&lt;dependency&gt;&lt;groupId&gt;javax.servlet&lt;/groupId&gt;&lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;&lt;version&gt;3.0.1&lt;/version&gt;&lt;/dependency&gt;&lt;/dependencies&gt; jetty插件 12345678910111213141516171819202122&lt;plugins&gt;&lt;!-- 编译环境插件 --&gt;&lt;plugin&gt;&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;&lt;version&gt;2.3.2&lt;/version&gt;&lt;configuration&gt;&lt;source&gt;1.7&lt;/source&gt;&lt;target&gt;1.7&lt;/target&gt;&lt;encoding&gt;UTF-8&lt;/encoding&gt;&lt;/configuration&gt;&lt;/plugin&gt;&lt;plugin&gt;&lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt;&lt;artifactId&gt;maven-jetty-plugin&lt;/artifactId&gt;&lt;version&gt;6.1.25&lt;/version&gt;&lt;configuration&gt;&lt;scanIntervalSeconds&gt;10&lt;/scanIntervalSeconds&gt;&lt;contextPath&gt;/springmvc01&lt;/contextPath&gt;&lt;/configuration&gt;&lt;/plugin&gt;&lt;/plugins&gt; 配置web.xml（前端控制器配置）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app id="WebApp_ID" version="3.0" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"&gt; &lt;!-- 表示容器启动时 加载上下文配置 这里指定spring 相关配置 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:*.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 启用spring容器环境上下文监听 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 编码过滤 utf-8 --&gt; &lt;filter&gt; &lt;description&gt;char encoding filter&lt;/description&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- servlet请求分发器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springMvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:servlet-context.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 表示启动容器时初始化该Servlet --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springMvc&lt;/servlet-name&gt; &lt;!-- 这是拦截请求, /代表拦截所有请求,拦截所有请求 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 配置servlet-context.xml1234567891011121314151617181920212223242526272829&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation=" http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;!-- 扫描com.shsxt.controller 下包 --&gt; &lt;context:component-scan base-package="com.shsxt.controller"/&gt; &lt;!-- mvc 请求映射 处理器与适配器配置--&gt; &lt;mvc:annotation-driven/&gt; &lt;!--配置视图解析器 默认的视图解析器- --&gt; &lt;bean id="defaultViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/&gt; &lt;property name="contentType" value="text/html"/&gt; &lt;property name="prefix" value="/WEB-INF/jsp/"/&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;/bean&gt;&lt;/beans&gt; 至此，环境配置基本完成了，我们来小试一波 测试添加视图页面（jsp页面）​ 因为我们在servlet-context.xml中配置的视图解析器，配置的是WEB-INF下的JSP目录和后缀.jsp，所以SpringMVC在解析视图的时候，只会解析改目录下的jsp文件，所以添加视图页面的时候需要新建一个jsp目录。 创建Controller类123456789@Controller // 定义为controller类@RequestMapping("hello") // 将url和类绑定public class HelloController &#123; @RequestMapping("index") // 将url和方法绑定 （配置映射关系） public String hello() &#123; return "hello_springmvc"; &#125;&#125; 启动和访问1、启动jetty 2、访问 本机ip:端口号/jetty的访问地址/类访问路径/方法访问路径]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mybatis学习(8)-mybatis Dao层、Service层封装]]></title>
    <url>%2Fdlh1234okok.github.io%2F2018%2F10%2F10%2FMybatis%E5%AD%A6%E4%B9%A0-8%2F</url>
    <content type="text"><![CDATA[Dao层 BaseMapper定义与实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.shsxt.base;import org.springframework.dao.DataAccessException;import java.util.List;import java.util.Map;public interface BaseMapper&lt;T&gt; &#123; /** * 添加记录不返回主键 * * @param entity * @return * @throws DataAccessException */ public int insert(T entity) throws DataAccessException; /** * * * @return * @throws DataAccessException */ public int insertBatch(List&lt;T&gt; entities) throws DataAccessException; /** * 查询总记录数 * @param map * @return */ @SuppressWarnings("rawtypes") public int queryCountByParams(Map map) throws DataAccessException; /** * 查询记录 通过 id * @param id * @return */ public T queryById(Integer id) throws DataAccessException; /** * 分页查询记录 * @return */ public List&lt;T&gt; queryForPage(BaseQuery baseQuery) throws DataAccessException; /** * 查询记录不带分页情况 * @param map * @return */ @SuppressWarnings("rawtypes") public List&lt;T&gt; queryByParams(Map map) throws DataAccessException; /** * 更新记录 * @param entity * @return */ public int update(T entity) throws DataAccessException; /** * 批量更新 * @param map * @return * @throws DataAccessException */ public int updateBatch(Map map) throws DataAccessException; /** * 删除记录 * @param id * @return */ public int delete(Integer id) throws DataAccessException; /** * 批量删除 * @param ids * @return */ public int deleteBatch(int[] ids) throws DataAccessException;&#125; Service层 BaseService层定义与实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134package com.shsxt.base;import com.github.pagehelper.PageHelper;import com.github.pagehelper.PageInfo;import org.springframework.beans.factory.annotation.Autowired;import java.util.List;import java.util.Map;public abstract class BaseService&lt;T&gt; &#123; @Autowired public BaseMapper&lt;T&gt; baseMapper; /** * 添加记录 * * @param entity * @return * @throws Exception */ public int insert(T entity) throws Exception &#123; int result = baseMapper.insert(entity); return result; &#125; /** * 批量添加记录 * * @param entities * @return * @throws Exception */ public int insertBatch(List&lt;T&gt; entities) throws Exception &#123; return baseMapper.insertBatch(entities); &#125; /** * 根据参数统计记录数 * * @param map * @return * @throws Exception */ @SuppressWarnings("rawtypes") public int queryCountByParams(Map map) throws Exception &#123; return baseMapper.queryCountByParams(map); &#125; /** * 查询记录通过 id * * @param id * @return * @throws Exception */ public T queryById(Integer id) throws Exception &#123; AssertUtil.isNull(id, "记录 id 非空!"); return baseMapper.queryById(id); &#125; /** * 分页查询 * * @param baseQuery * @return * @throws Exception */ public PageInfo&lt;T&gt; queryForPage(BaseQuery baseQuery) throws Exception &#123; PageHelper.startPage(baseQuery.getPageNum(), baseQuery.getPageSize()); List&lt;T&gt; list = baseMapper.queryForPage(baseQuery); PageInfo&lt;T&gt; pageInfo = new PageInfo&lt;T&gt;(list); return pageInfo; &#125; /** * * * * @param map * @return * @throws Exception */ @SuppressWarnings("rawtypes") public List&lt;T&gt; queryByParams(Map map) throws Exception &#123; return baseMapper.queryByParams(map); &#125; /** * 查询记录 * * @param entity * @return * @throws Exception */ public int update(T entity) throws Exception &#123; return baseMapper.update(entity); &#125; /** * 批量更新 * * @param map * @return * @throws Exception */ @SuppressWarnings("rawtypes") public int updateBatch(Map map) throws Exception &#123; return baseMapper.updateBatch(map); &#125; /** * 删除记录 * * @param id * @return * @throws Exception */ public int delete(Integer id) throws Exception &#123;// 判断 空 AssertUtil.isNull(id, "记录 id 非空！"); AssertUtil.isNull(queryById(id), "待删除的记录不存在!"); return baseMapper.delete(id); &#125; /** * 批量删除 * * @param ids * @return */ public int deleteBatch(int[] ids) throws Exception &#123; AssertUtil.isNull(ids.length == 0, "请至少选择一项记录!"); return baseMapper.deleteBatch(ids); &#125;&#125; BaseQuery类封装12345678910111213141516171819202122232425262728package com.shsxt.base;public class BaseQuery &#123; /** * 分页页码 */ private int pageNum = 1; /** * 每页记录数 */ private int pageSize = 10; public int getPageNum() &#123; return pageNum; &#125; public void setPageNum(int pageNum) &#123; this.pageNum = pageNum; &#125; public int getPageSize() &#123; return pageSize; &#125; public void setPageSize(int pageSize) &#123; this.pageSize = pageSize; &#125;&#125; 参数异常处理1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.shsxt.base;public class AssertUtil &#123; /** * 表达式结果真时判断 * * @param msg */ public static void isTrue(Boolean expression, String msg) &#123; if (expression) &#123; throw new ParamException(msg); &#125; &#125; public static void isTure(Boolean expression) &#123; if (expression) &#123; throw new ParamException("false"); &#125; &#125; /** * 参数为空时 * * @param object * @param msg */ public static void isNull(Object object, String msg) &#123; if (object == null) &#123; throw new ParamException(msg); &#125; &#125; /** * 参数不空时 * * @param object * @param msg */ public static void notNull(Object object, String msg) &#123; if (object != null) &#123; throw new ParamException(msg); &#125; &#125;&#125; 异常类定义123456789101112131415161718192021222324252627282930313233343536373839404142package com.shsxt.base;/** * 参数异常类 * * @author Administrator */public class ParamException extends RuntimeException &#123; /** * * * / * private static final long serialVersionUID = -5962296753554846774L; * /** * 错误状态码 */ private int errorCode; public ParamException() &#123; &#125; /** * 错误消息 * * @param msg */ public ParamException(String msg) &#123; super(msg); &#125; public ParamException(int errorCode, String msg) &#123; super(msg); this.errorCode = errorCode; &#125; public int getErrorCode() &#123; return errorCode; &#125; public void setErrorCode(int errorCode) &#123; this.errorCode = errorCode; &#125;&#125; 使用1、Dao层接口继承BaseMapper 12@Repositorypublic interface UserDao extends BaseMapper&lt;User&gt; &#123;&#125; 2、Service层继承BaseService 12@Servicepublic class UserService extends BaseService&lt;User&gt; &#123;&#125; 3、不需要写任何代码，直接单元测试（映射sql文件中的sql已经自动生成） 1234@Testpublic void test01() throws Exception &#123; System.out.println(userService.queryById(6));;&#125;]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mybatis学习(7)-mybatis代码自动化生成]]></title>
    <url>%2Fdlh1234okok.github.io%2F2018%2F10%2F10%2FMybatis%E5%AD%A6%E4%B9%A0-7%2F</url>
    <content type="text"><![CDATA[借助Maven插件实现mybatis基本crud代码生成 配置pom.xml123456789101112&lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;configuration&gt; &lt;configurationFile&gt;src/main/resources/generatorConfig.xml&lt;/configurationFile&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; 配置generatorConfig.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt; &lt;!--数据库驱动--&gt; &lt;!--数据库驱动jar包路径--&gt; &lt;classPathEntry location="G:\Java\repository\mysql\mysql-connector-java\5.1.39\mysql-connector-java-5.1.39.jar"/&gt; &lt;context id="DB2Tables" targetRuntime="MyBatis3"&gt; &lt;commentGenerator&gt; &lt;property name="suppressDate" value="true"/&gt; &lt;property name="suppressAllComments" value="true"/&gt; &lt;/commentGenerator&gt; &lt;!--数据库链接地址账号密码--&gt; &lt;jdbcConnection driverClass="com.mysql.jdbc.Driver" connectionURL="jdbc:mysql://127.0.0.1:3306/mybatis" userId="root" password="123456"&gt; &lt;/jdbcConnection&gt; &lt;javaTypeResolver&gt; &lt;property name="forceBigDecimals" value="false"/&gt; &lt;/javaTypeResolver&gt; &lt;!--生成 Model 类存放位置--&gt; &lt;javaModelGenerator targetPackage="com.shsxt.po" targetProject="G:\idea\Workspaces\spring_mybatis\src\main\java" &gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;property name="trimStrings" value="true"/&gt; &lt;/javaModelGenerator&gt; &lt;!--生成映射文件存放位置--&gt; &lt;sqlMapGenerator targetPackage="com.shsxt.mapper" targetProject="G:\idea\Workspaces\spring_mybatis\src\main\java" &gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;/sqlMapGenerator&gt; &lt;!--生成 Dao 类存放位置--&gt; &lt;javaClientGenerator type="XMLMAPPER" targetPackage="com.shsxt.dao" targetProject="G:\idea\Workspaces\spring_mybatis\src\main\java" &gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;/javaClientGenerator&gt; &lt;!--tableName：数据库中的表名 domainObjectName:要生成的实体类类名--&gt; &lt;table tableName="account" domainObjectName="Account" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"&gt;&lt;/table&gt; &lt;table tableName="card" domainObjectName="Card" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"&gt;&lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 执行配置 ​ 执行成功后，会自动生成对应的实体类，mybatis映射文件，映射接口类，其中基本sql也已经自动生成了。]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mybatis学习(6)-分页插件]]></title>
    <url>%2Fdlh1234okok.github.io%2F2018%2F10%2F10%2FMybatis%E5%AD%A6%E4%B9%A0-6%2F</url>
    <content type="text"><![CDATA[添加依赖12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;4.1.0&lt;/version&gt; &lt;/dependency&gt; 修改mybatis配置文件12345678910111213141516171819202122232425262728293031&lt;plugins&gt; &lt;!-- com.github.pagehelper 为 PageHelper 类所在包名 --&gt; &lt;plugin interceptor="com.github.pagehelper.PageHelper"&gt; &lt;property name="dialect" value="mysql"/&gt; &lt;!-- 该参数默认为 false --&gt; &lt;!-- 设置为 true 时，会将 RowBounds 第一个参数 offset 当成 pageNum 页码使 用 --&gt; &lt;!-- 和 startPage 中的 pageNum 效果一样 --&gt; &lt;property name="offsetAsPageNum" value="true"/&gt; &lt;!-- 该参数默认为 false --&gt; &lt;!-- 设置为 true 时，使用 RowBounds 分页会进行 count 查询 --&gt; &lt;property name="rowBoundsWithCount" value="true"/&gt; &lt;!-- 设置为 true 时，如果 pageSize=0 或者 RowBounds.limit = 0 就会查询出 全部的结果 --&gt; &lt;!-- （相当于没有执行分页查询，但是返回结果仍然是 Page 类型） --&gt; &lt;property name="pageSizeZero" value="true"/&gt; &lt;!-- 3.3.0 版本可用 - 分页参数合理化，默认 false 禁用 --&gt; &lt;!-- 启用合理化时，如果 pageNum&lt;1 会查询第一页，如果 pageNum&gt;pages 会 查询最后一页 --&gt; &lt;!-- 禁用合理化时，如果 pageNum&lt;1 或 pageNum&gt;pages 会返回空数据 --&gt; &lt;property name="reasonable" value="true"/&gt; &lt;!-- 3.5.0 版本可用 - 为了支持 startPage(Object params)方法 --&gt; &lt;!-- 增加了一个`params`参数来配置参数映射，用于从 Map 或 ServletRequest 中取值 --&gt; &lt;!-- 可以配置 pageNum,pageSize,count,pageSizeZero,reasonable,不配置映 射的用默认值 --&gt; &lt;property name="params" value="pageNum=start;pageSize=limit;pageSizeZero=zero;reasonable=heli;count=countsql"/&gt; &lt;/plugin&gt; &lt;/plugins&gt; 添加对应接口查询分页方法12345678910111213/** * @param pageNum 页号 * @param pageSize 每页显示的数量 * @param userName 参数 * @return */ public PageInfo&lt;User&gt; queryUsersByParams(Integer pageNum,Integer pageSize,String userName)&#123; // 设置分页页号和每页显示数量 PageHelper.startPage(pageNum,pageSize); List&lt;User&gt; users = userDao.queryUsersByParams(userName); PageInfo&lt;User&gt; pageInfo = new PageInfo&lt;&gt;(users); return pageInfo; &#125; 单元测试1234567@Test public void test02()&#123; PageInfo&lt;User&gt; pageInfo = userService.queryUsersByParams(1,3,null); System.out.println(pageInfo.getPages()+"=="+pageInfo.getTotal()); List&lt;User&gt; users = pageInfo.getList(); for(User user:users) System.out.println(user); &#125;]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mybatis学习(5)-整合spring]]></title>
    <url>%2Fdlh1234okok.github.io%2F2018%2F10%2F10%2FMybatis%E5%AD%A6%E4%B9%A0-5%2F</url>
    <content type="text"><![CDATA[添加依赖1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!-- spring 核心 jar --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring 测试 jar --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.3.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring jdbc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;4.3.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring 事物 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;4.3.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- aspectj 切面编程的 jar --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.9&lt;/version&gt; &lt;/dependency&gt; &lt;!-- c3p0 连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加 mybatis 与 Spring 整合的核心包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql 驱动包 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.39&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志打印相关的 jar --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.2&lt;/version&gt; &lt;/dependency&gt; 添加配置文件log4j123456# Global logging configurationlog4j.rootLogger=DEBUG, stdout# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n db12345jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf8jdbc.username=rootjdbc.password=123456 mybatis123456789&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- po 包扫描 --&gt; &lt;typeAliases&gt; &lt;package name="com.shsxt.po"/&gt; &lt;/typeAliases&gt;&lt;/configuration&gt; spring12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context.xsdhttp://www.springframework.org/schema/aophttp://www.springframework.org/schema/aop/spring-aop.xsdhttp://www.springframework.org/schema/txhttp://www.springframework.org/schema/tx/spring-tx-3.0.xsd"&gt; &lt;!-- 扫描 com.shsxt 及其所有子包下类 --&gt; &lt;context:component-scan base-package="com.shsxt" /&gt; &lt;!-- 加载 properties 配置文件 --&gt; &lt;context:property-placeholder location="classpath:db.properties" /&gt; &lt;aop:aspectj-autoproxy /&gt;&lt;!-- aop --&gt; &lt;!-- 配置数据源 --&gt; &lt;!-- 配置 c3p0 数据源 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="$&#123;jdbc.driver&#125;"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.url&#125;"&gt;&lt;/property&gt; &lt;property name="user" value="$&#123;jdbc.username&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 设置事物增强 --&gt; &lt;tx:advice id="txAdvice" transaction-manager="txManager"&gt; &lt;tx:attributes&gt; &lt;tx:method name="get*" read-only="true" /&gt; &lt;tx:method name="find*" read-only="true" /&gt; &lt;tx:method name="query*" read-only="true" /&gt; &lt;tx:method name="load*" read-only="true" /&gt; &lt;tx:method name="add*" propagation="REQUIRED" /&gt; &lt;tx:method name="insert*" propagation="REQUIRED" /&gt; &lt;tx:method name="update*" propagation="REQUIRED"/&gt; &lt;tx:method name="delete*" propagation="REQUIRED" /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- aop 切面配置 --&gt; &lt;aop:config&gt; &lt;aop:pointcut id="servicePointcut" expression="execution(*com.shsxt.service..*.*(..))" /&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="servicePointcut"/&gt; &lt;/aop:config&gt; &lt;!-- 配置 sqlSessionFactory--&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;property name="configLocation" value="classpath:mybatis.xml" /&gt; &lt;!-- 自动扫描 com/shsxt/crm/mapper 目录下的所有 SQL 映射的 xml 文 件, 省掉 mybatis.xml 里的手工配置 value="classpath:com/shsxt/crm/mapper/*.xml"指的是 classpath(类路径) 下 com.shsxt.crm.mapper 包中的所有 xml 文件 UserMapper.xml 位于 com.shsxt.mapper 包下，这样 UserMapper.xml 就可 以被自动扫描 --&gt; &lt;property name="mapperLocations" value="classpath:com/shsxt/mapper/*.xml" /&gt; &lt;/bean&gt; &lt;!-- 配置扫描器 --&gt; &lt;bean id="mapperScanner" class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;!-- 扫描 com.shsxt.dao 这个包以及它的子包下的所有映射接口类 --&gt; &lt;property name="basePackage" value="com.shsxt.dao" /&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory" /&gt; &lt;/bean&gt;&lt;/beans&gt; mybatis映射sql文件1234567&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.shsxt.dao.UserMapper"&gt;&lt;/mapper&gt; 目录结构 单元测试12345678910@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = "classpath:spring.xml")public class Test01 &#123; @Resource private UserService userService; @Test public void test01()&#123; System.out.println(userService.queryUserById(6)); &#125;&#125;]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mybatis学习(4)-缓存]]></title>
    <url>%2Fdlh1234okok.github.io%2F2018%2F10%2F10%2FMybatis%E5%AD%A6%E4%B9%A0-4%2F</url>
    <content type="text"><![CDATA[简介​ 缓存在数据库查询中就是将查询出来的数据存到内存或者磁盘中，以便下次再进行同样查询操作的时候可以直接读取。相比于到数据库中重新查询，从内存或磁盘中读取数据更加快速。 ​ 正如大多数持久层框架一样，mybatis同样提供了一级缓存和二级缓存 ​ 1、一级缓存：基于PerpetualCache的HashMap本地缓存，其存储作用域为Session，当Session flush或close之后，该Session中的所有Cache就将清空。 ​ 2、二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache 的 HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache； ​ 对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了 C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。 ​ 如果二级缓存开启，首先从二级缓存查询数据，如果二级缓存有则从二级缓存中获取数据，如果没有则到一级缓存中查询，如果有就从一级缓存中获取，如果一级缓存中没有，再查询数据库。 一级缓存​ mybatis默认开启一级缓存，当连续进行一个sql查询的时候，第二次查询就是从缓存中读取。 1234567@Test public void test05()&#123; Integer total1 = userMapper.queryUserCount(); System.out.println(total1); Integer total2 = userMapper.queryUserCount(); System.out.println(total2); &#125; 我们发现只执行了一条sql，当在两次查询中间刷新缓存后，结果是： 二级缓存mybatis提供了二级缓存，但需要手动开启。 ​ 1、在mybatis配置文件中全局开启二级缓存（位置在properties标签下面） ​ 2、在需要的Mapper.xml映射文件中加入二级缓存 至此已经开启了二级缓存，映射语句文件中所有的select语句将会被缓存 测试结果： ​ 发现也只执行了一遍sql查询，“Cache Hit Ratio”缓存命中率，说明第二次查询是从缓存中读取。 补充说明： ​ 1、映射语句文件中所有的insert、update、delete语句都会刷新缓存。 ​ 2、缓存会使用Least Recently Used（LRU，最近最少使用）算法来回收 ​ 3、缓存会根据指定时间间隔来刷新 ​ 4、缓存会存储1024个对象 使用场景：​ 1、 对查询频率高， 变化频率低的数据建议使用二级缓存。​ 2、 对于访问多的查询请求且用户对查询结果实时性要求不高， 此时可采用mybatis 二级缓存技术降低数据库访问量， 提高访问速度， 业务场景比如： 耗时较高的统计分析 sql、 电话账单查询 sql 等 Cache标签常用属性： 12345&lt;cache eviction="FIFO" &lt;!--回收策略为先进先出--&gt;flushInterval="60000" &lt;!--自动刷新时间60s--&gt;size="512" &lt;!--最多缓存512个引用对象--&gt;readOnly="true"/&gt; &lt;!--只读--&gt; 分布式缓存Ehcache1、引入依赖 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt; &lt;artifactId&gt;ehcache-core&lt;/artifactId&gt; &lt;version&gt;2.4.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt; &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt; &lt;version&gt;1.0.3&lt;/version&gt; &lt;/dependency&gt; 2、缓存接口配置 1&lt;cache type="org.mybatis.caches.ehcache.EhcacheCache"/&gt; 3、添加配置文件（可以不设置，默认） 12345678910111213141516171819202122232425262728293031323334&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;ehcache xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../bin/ehcache.xsd"&gt; &lt;!-- name：Cache 的唯一标识 maxElementsInMemory：内存中最大缓存对象数 maxElementsOnDisk：磁盘中最大缓存对象数，若是 0 表示无穷大 eternal：Element 是否永远不过期，如果为 true，则缓存的数据始终有效，如果为 false 那么还要根据 timeToIdleSeconds，timeToLiveSeconds 判断 overflowToDisk：配置此属性，当内存中 Element 数量达到 maxElementsInMemory 时， Ehcache 将会 Element 写到磁盘中 timeToIdleSeconds：设置 Element 在失效前的允许闲置时间。仅当 element 不是永久有效 时使用，可选属性，默认值是 0，也就是可闲置时间无穷大 timeToLiveSeconds：设置 Element 在失效前允许存活时间。最大时间介于创建时间和失效 时间之间。仅当 element 不是永久有效时使用，默认是 0.，也就是 element 存活时间无穷 大 di skPersistent：是否缓存虚拟机重启期数据 diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是 120 秒 diskSpoolBufferSizeMB：这个参数设置 DiskStore（磁盘缓存）的缓存区大小。默认是 30MB。每个 Cache 都应该有自己的一个缓冲区上海尚学智能科技有限公司 memoryStoreEvictionPolicy：当达到 maxElementsInMemory 限制时，Ehcache 将会根据 指定的策略去清理内存。默认策略是 LRU（最近最少使用）。你可以设置为 FIFO（先进先 出）或是 LFU（较少使用） --&gt; &lt;defaultCache overflowToDisk="true" eternal="false"/&gt; &lt;diskStore path="D:/cache" /&gt; &lt;!-- &lt;cache name="sxtcache" overflowToDisk="true" eternal="false" timeToIdleSeconds="300" timeToLiveSeconds="600" maxElementsInMemory="1000" maxElementsOnDisk="10" diskPersistent="true" diskExpiryThreadIntervalSeconds="300" diskSpoolBufferSizeMB="100" memoryStoreEvictionPolicy="LRU" /&gt; --&gt;&lt;/ehcache&gt;]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mybatis学习(3)-映射关系处理]]></title>
    <url>%2Fdlh1234okok.github.io%2F2018%2F10%2F10%2FMybatis%E5%AD%A6%E4%B9%A0-3%2F</url>
    <content type="text"><![CDATA[简介​ 数据库大类分为关系型数据库和非关系型数据库，关系型数据库有Mysql、Oracle、Sql Server等，非关系型数据库有MongoDB、Redis等。 ​ 关系型数据库中的映射关系主要有： ​ 一对一：比如一个人对应一个身份证号码 ​ 一对多（多对一）：父亲对孩子，一个父亲可以多个孩子，而一个孩子只会有一个父亲 ​ 多对多：一个学生可以选择多门课程，而一门课程可以给多个学生选择 ​ 处理映射关系如何处理这些关系映射？ ​ 一对一：在一个数据表中添加另一个表的主键作为外键 ​ 一对多：建立一个中间表 ​ 多对多：拆分成两个一对多 在mybatis环境中实现 ​ 因为我们实体类中的字段最好是固定不变的，所以当需要用到另外一张表的字段时新建一个类来对应，我们把它们放到DTO层，专门用来装这些组合的不完整的数据实体。 1、一对一 新建一个实体类 1234567891011121314151617181920212223public class UserCardDto &#123; private User user; private Card card; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; public Card getCard() &#123; return card; &#125; public void setCard(Card card) &#123; this.card = card; &#125; @Override public String toString() &#123; return "UserCardDto&#123;" + "user=" + user + ", card=" + card + '&#125;'; &#125;&#125; 在mapper.xml中编写sql 123456789101112131415161718192021222324&lt;!--一对一--&gt; &lt;resultMap id="user_card_map" type="userCardDto"&gt; &lt;!--property：实体类中成员变量名--&gt; &lt;!--变量类型（别名）--&gt; &lt;association property="user" javaType="user"&gt; &lt;id column="userId" property="userId"/&gt; &lt;result column="userName" property="userName"/&gt; &lt;result column="userPwd" property="userPwd"/&gt; &lt;result column="nickName" property="userNick"/&gt; &lt;result column="card_id" property="cardId"/&gt; &lt;/association&gt; &lt;association property="card" javaType="card"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="card_num" property="cardNum"/&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id="queryCardUserById" parameterType="int" resultMap="user_card_map"&gt; select u.userName,u.nickName,c.card_num from user u left join card c on u.card_id=c.id where u.userId=#&#123;userId&#125; &lt;/select&gt; 2、一对多 12345678910111213141516171819202122232425262728293031public class UserCardAccountDto implements Serializable &#123; private User user; private Card card; private List&lt;Account&gt; accounts; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; public Card getCard() &#123; return card; &#125; public void setCard(Card card) &#123; this.card = card; &#125; public List&lt;Account&gt; getAccounts() &#123; return accounts; &#125; public void setAccounts(List&lt;Account&gt; accounts) &#123; this.accounts = accounts; &#125; @Override public String toString() &#123; return "UserCardAccountDto&#123;" + "user=" + user + ", card=" + card + ", accounts=" + accounts + '&#125;'; &#125;&#125; 123456789101112131415161718192021222324&lt;resultMap id="user_card_acc_map" extends="user_card_map" type="userCardAccountDto"&gt; &lt;!--property:字段名--&gt;&lt;!--ofType:集合中元素的类型--&gt; &lt;collection property="accounts" ofType="account"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="aname" property="aname"/&gt; &lt;result column="type" property="type"/&gt; &lt;result column="money" property="money"/&gt; &lt;result column="userId" property="userId"/&gt; &lt;result column="create_time" property="create_time"/&gt; &lt;result column="update_time" property="update_time"/&gt; &lt;result column="remark" property="remark"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id="queryUserCardAccountById" parameterType="int" resultMap="user_card_acc_map"&gt; select u.userId,u.userName,u.userPwd,u.userNick,u.card_id, c.id,c.card_num, a.id,a.aname,a.type,a.money,a.remark,a.create_time,a.update_time from user u left join card c on u.card_id=c.id left join account a on u.userId=a.userId where u.userId=#&#123;userId&#125; &lt;/select&gt; 查询出来的结果天然去重]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mybatis学习(2)-CRUD操作..]]></title>
    <url>%2Fdlh1234okok.github.io%2F2018%2F10%2F09%2FMybatis%E5%AD%A6%E4%B9%A0-2%2F</url>
    <content type="text"><![CDATA[增删改查​ 需要进行增删改查操作时，需要在映射文件中配置不同的标签，有常用参数parameterType，resultType等。除了查询操作时需要配置返回结果类型（resultType）标签，其他三种操作都不需要添加。 ​ 参数类型（parameterType）有：基本数据类型,字符串,map,java bean,list等 ​ 返回结果类型（resultType）有：基本数据类型,字符串,map,java bean,list等 查询操作（select）123&lt;select id="queryMapById" parameterType="int" resultType="map"&gt; select * from user where userId=#&#123;userId&#125;&lt;/select&gt; 添加操作（insert）（1）添加不返回主键 1234&lt;!--添加不返回主键--&gt; &lt;insert id="addUser" parameterType="user"&gt; insert into user (userName, userPwd, userNick) values (#&#123;userName&#125;,#&#123;userPwd&#125;,#&#123;userNick&#125;) &lt;/insert&gt; （2）添加返回主键（这里使用的是mysql） 1234567&lt;!--添加返回主键1--&gt; &lt;insert id="addUserHasKey" parameterType="user"&gt; &lt;selectKey keyProperty="userId" order="AFTER" resultType="int"&gt; select LAST_INSERT_ID() as id &lt;/selectKey&gt; insert into user (userName, userPwd, userNick) values (#&#123;userName&#125;,#&#123;userPwd&#125;,#&#123;userNick&#125;) &lt;/insert&gt; 1234&lt;!--添加返回主键2 推荐--&gt; &lt;insert id="addUserHasKey2" parameterType="user" useGeneratedKeys="true" keyProperty="userId"&gt; insert into user (userName, userPwd, userNick) values (#&#123;userName&#125;,#&#123;userPwd&#125;,#&#123;userNick&#125;) &lt;/insert&gt; ​ useGeneratedKeys:使用自动生成key ​ keyProperty:数据库中主键的名字 ​ 注意：mapper接口返回的依然是受影响的行数，但是主键已经赋值到实体类对象的id中了 （3）批量添加 1234567&lt;!--批量添加--&gt; &lt;insert id="addUserBatch" parameterType="list"&gt; insert into user (userName, userPwd, userNick) values &lt;foreach collection="list" item="item" separator=","&gt; (#&#123;item.userName&#125;,#&#123;item.userPwd&#125;,#&#123;item.userNick&#125;) &lt;/foreach&gt; &lt;/insert&gt; 删除操作（delete）123456789101112&lt;!--删除--&gt; &lt;delete id="deleteUser" parameterType="int"&gt; delete from user where userId=#&#123;userId&#125; &lt;/delete&gt; &lt;!--批量删除--&gt; &lt;delete id="deleteUserBatch" parameterType="list"&gt; delete from user where userId in( &lt;foreach collection="list" item="item" separator=","&gt; #&#123;item&#125; &lt;/foreach&gt; ) &lt;/delete&gt; 更新操作（update）123456789101112&lt;!--更新--&gt; &lt;update id="updateUser" parameterType="user"&gt; update user set userPwd=#&#123;userPwd&#125; where userId=#&#123;userId&#125; &lt;/update&gt; &lt;!--批量更新--&gt; &lt;update id="updateUserBatch" parameterType="int"&gt; update user set userPwd="8888" where userId in ( &lt;foreach collection="array" item="item" separator=","&gt; #&#123;item&#125; &lt;/foreach&gt; ) &lt;/update&gt; 设置事务自动提交在增删改操作中，默认不会自动进行事务提交，需要进行设置才会自动提交 1、在创建session时设置 1SqlSession sqlSession = sessionFactory.openSession(true); 2、commit方法 12SqlSession sqlSession = sessionFactory.openSession();sqlSession.commit(); 使用sql片段​ 发现在编写sql时，有很多重复的语句或者语段，为了复用这些语句，可以编写sql语句段 1234&lt;!--sql片段--&gt; &lt;sql id="base"&gt; user (userName, userPwd, userNick) &lt;/sql&gt; 然后可以在需要使用这段语句的地方使用“include”引用，如： 1234&lt;!--添加返回主键2--&gt; &lt;insert id="addUserHasKey2" parameterType="user" useGeneratedKeys="true" keyProperty="userId"&gt; insert into &lt;include refid="base"/&gt; values (#&#123;userName&#125;,#&#123;userPwd&#125;,#&#123;userNick&#125;) &lt;/insert&gt; #{}和${}的区别12select * from user where name = #&#123;name&#125;; select * from user where name = '$&#123;name&#125;'; #{}在动态解析时，会解析成一个参数占位符?，所以解析之后的语句是： 1select * from user where name = ?; ${}在动态解析时，会将我们填充的参数当做字符串的形式填充到语句中，结果是： 1select * from user where name = "zhangsan"; #{}能够很大程度防止sql注入，而${}不能；${}方式一般用于插入一个不改变的字符串，比如order by ${type}，或是在传入表名时。一般我们尽量使用#{}的方式。 resultMap​ 当数据库中字段名和对应java bean中的变量名不同时，总是需要在sql语句中使用as取别名来将查询出来的字段名转换为和java bean中的相同。此时使用resultMap可以将数据库中查询出来的结果自动映射成java bean。 123456&lt;resultMap id="resMap" type="user"&gt; &lt;id column="userId" property="userId"/&gt; &lt;!--主键--&gt; &lt;result column="userName" property="userName"/&gt; &lt;result column="userPwd" property="userPwd"/&gt; &lt;result column="userNick" property="userNick"/&gt; &lt;/resultMap&gt; ​ type：java bean的别名 ​ column：数据库中的字段名 ​ property：java bean中的变量名 因为我在数据库中的字段名和java中的变量名取的是相同的，所以写的也一样，这里只做一个演示 将resultType替换resultMap，值和id对应 mapper接口代理​ 遵循mybatis开发规范，mybatis框架可以自动生成mapper接口对象 ​ 1、mapper.xml中namespace等于接口类全限定名 ​ 2、mapper.java接口中方法名必须与mapper.xml中statement id一致 ​ 3、接口中输入参数类型必须与parameterType参数类型一致 ​ 4、接口中方法的返回值类型必须与映射文件中对应返回值类型一致 ​ 非集成环境：接口名与映射文件名称一致，映射文件与接口处于同一个包中 此时可以通过getMapper()方法传入接口的class对象返回接口的对象，所以测试代码可以这么写： 12345678@Testpublic void test01() throws IOException &#123; InputStream is = Resources.getResourceAsStream("mybatis.xml"); SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(is); SqlSession sqlSession = sessionFactory.openSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); System.out.println(userMapper.queryMapById(1));&#125; 动态sqlmybatis的强大特性就是它的动态sql，动态sql顾名思义就是随着传入的参数动态产生不同的sql。 使用动态sql时需要在接口方法参数中设置@param指定参数才能将参数传入if等条件中： 1public List&lt;User&gt; queryUsersByName(@Param("userName") String userName); if条件判断123456&lt;select id="queryUsersByName" parameterType="string" resultType="user"&gt; select * from user where 1=1 &lt;if test="null!=userName and ''!=userName"&gt; and userName like concat('%',#&#123;userName&#125;,'%') &lt;/if&gt; &lt;/select&gt; ​ 当使用动态sql时，为了防止sql语句结构不当，所以加上where 1=1。在段代码中只有当if中的条件成立时，才会拼接上其中的代码。 choose when otherwise​ 这个类似于java中的switch-case-default 123456789101112&lt;select id="queryUserByNick" parameterType="string" resultType="user"&gt; select userId &lt;choose&gt; &lt;when test="null!=userNick and ''!=userNick"&gt; ,userName,userNick &lt;/when&gt; &lt;otherwise&gt; ,userPwd &lt;/otherwise&gt; &lt;/choose&gt; from user where 1=1 &lt;/select&gt; Ognl表达式​ 我们在进行if或者choose-when-outherwise进行判断的时候经常要写判断条件如 1&lt;if test="null!=userName and ''!=userName"&gt;&lt;/if&gt; ​ 此时我们可以用Ognl访问工具类来简化这里的编写，表达式格式为：@class@method(args)，上面这条判断使用之后的格式是： 1&lt;if test="@Ognl@isNotEmpty(userName)"&gt;&lt;/if&gt; trim where set标签​ 在我们使用动态sql的时候，sql中总有些连接词不能正常拼接，比如下面的代码： 12345678910&lt;select id="queryUserByNameOrNick" parameterType="user" resultType="user"&gt; select * from user where &lt;if test="@Ognl@isNotEmpty(userName)"&gt; userName like concat('%',#&#123;userName&#125;,'%') &lt;/if&gt; &lt;if test="@Ognl@isNotEmpty(userNick)"&gt; and userNick like concat('%',#&#123;userNick&#125;,'%') &lt;/if&gt; &lt;/select&gt; ​ 这段sql中当第一个if不满足而第二个if满足时，sql拼接where条件后面就会多一个and，此时查询就会报异常，为了避免这种问题，可以使用where标签将条件内容包含起来，这个标签相当于一个where，而且在里面的动态sql会自动去除多余的and。 使用where标签后： 1234567891011&lt;select id="queryUserByNameAndNick" parameterType="user" resultType="user"&gt; select * from user &lt;where&gt; &lt;if test="@Ognl@isNotEmpty(userName)"&gt; userName like concat('%',#&#123;userName&#125;,'%') &lt;/if&gt; &lt;if test="@Ognl@isNotEmpty(userNick)"&gt; and userNick like concat('%',#&#123;userNick&#125;,'%') &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; ​ ​ set标签和where类似，set标签是在做更新操作的时候（update tbName set id=? where xxx）使用，同时更新多个字段，总会出现多余的“，”，使用set标签即可去除它们。 ​ trim标签既有where标签的作用又有set标签的作用： 1234567891011&lt;select id="queryUserByNameAndNick" parameterType="user" resultType="user"&gt; select * from user &lt;trim prefix="where" prefixOverrides="and|or"&gt; &lt;if test="@Ognl@isNotEmpty(userName)"&gt; userName like concat('%',#&#123;userName&#125;,'%') &lt;/if&gt; &lt;if test="@Ognl@isNotEmpty(userNick)"&gt; and userNick like concat('%',#&#123;userNick&#125;,'%') &lt;/if&gt; &lt;/trim&gt; &lt;/select&gt; forEach标签类似于JSTL的c:foreach标签，对一个集合进行遍历，通常在in或者插入多条数据时使用，如： 1234567&lt;!--批量添加--&gt; &lt;insert id="addUserBatch" parameterType="list"&gt; insert into user (userName, userPwd, userNick) values &lt;foreach collection="list" item="item" separator=","&gt; (#&#123;item.userName&#125;,#&#123;item.userPwd&#125;,#&#123;item.userNick&#125;) &lt;/foreach&gt; &lt;/insert&gt; 注解形式动态sql不常用，需要新建一个类来写sql语句 1、在接口方法上加上注解，如： 12@SelectProvider(method = "queryUserCount",type = UserProvider.class)public Integer queryUserCount(); ​ type指定sql类的class，method指定sql方法名 2、编写sql 123456789public class UserProvider &#123; public String queryUserCount()&#123; String total= new SQL()&#123;&#123; SELECT("count(*)"); FROM("user"); &#125;&#125;.toString(); return total; &#125;&#125; 这里的方法的返回值和接口方法的返回值不对应]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mybatis学习(1)-搭建和简单查询]]></title>
    <url>%2Fdlh1234okok.github.io%2F2018%2F10%2F09%2FMybatis%E5%AD%A6%E4%B9%A0-1%2F</url>
    <content type="text"><![CDATA[简介​ mybatis框架是一个基于java的持久层框架。持久层就是将数据存到持久化设备上（如数据库、硬盘等），它对于jdbc和持久层的操作做了简化，将sql和代码分离。 ​ mybatis不是一个完全的orm（对象关系映射）框架，和hibernate（对象关系映射框架）相比，它还需要自己编写sql语句，但是在某些业务逻辑多变的场景下，它可以由自己编写sql语句就显得更加灵活。 环境搭建maven项目 导入依赖​ mybatis核心依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt; &lt;/dependency&gt; ​ mysql驱动 12345&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.38&lt;/version&gt; &lt;/dependency&gt; ​ log4j依赖（可以输出操作过程，更容易在出错时找到问题） 12345&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; 添加mybatis配置文件12345678910111213141516171819202122232425262728&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 注册属性文件 --&gt; &lt;properties resource="jdbc.properties"/&gt; &lt;typeAliases&gt; &lt;!--配置实体类别名：包扫描 默认别名是类名--&gt; &lt;package name="com.shsxt.po"/&gt; &lt;/typeAliases&gt; &lt;!-- 配置MyBatis运行环境 --&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;driver&#125;"/&gt; &lt;property name="url" value="$&#123;url&#125;"/&gt; &lt;property name="username" value="$&#123;user&#125;"/&gt; &lt;property name="password" value="$&#123;password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;!-- 在这里可以配置另一个环境 --&gt; &lt;/environments&gt; &lt;!-- 注册映射文件 --&gt; &lt;mappers&gt; &lt;package name="com.shsxt.mapper"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; ​ 在配置时可以配置多个运行环境，默认运行标签指定的默认环境（上面为development环境），在需要切换环境时，可以在创建session工厂时指定，如： 1sqlSessionFactory = new SqlSessionFactoryBuilder().build(is,"test"); 配置映射文件（sql代码所在）​ 配置映射文件的方式有三种： 12345678&lt;mappers&gt; &lt;!--包扫描--&gt; &lt;package name="com.shsxt.mapper"/&gt; &lt;!--配置xml--&gt; &lt;mapper resource="com.shsxt.mapper.UserMapper"/&gt; &lt;!--配置接口--&gt; &lt;mapper class="com.shsxt.mapper.UserMapper"/&gt; &lt;/mappers&gt; ​ 一个实体类对应一个映射文件，所以当业务复杂有多个实体类时，包扫描的配置方式较为方便，而配置xml和配置接口都需要配置多个mapper标签。 创建一个xml文件作为映射文件，在java目录（因为不在resources目录下不会自动读取配置文件，所以需要指定java目录下读取配置文件） 1234567891011121314&lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.tld&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; xml映射文件 123456789101112&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.shsxt.mapper.UserMapper"&gt; &lt;!--数字--&gt; &lt;select id="queryUserByName" parameterType="string" resultType="user"&gt; select * from user where userName like concat('%',#&#123;userName&#125;,'%') &lt;!--concat:拼接字符串--&gt; &lt;/select&gt;&lt;/mapper&gt; namespace：指明命名空间，等于接口的全限定名，后面调用crud操作的时候需要 parameterType：指明输入参数类型（int,string,map,java bean,list..） resultType：指明输出数据类型（基本数据类型,string,map,java bean,list） ​ 在这里输出类型如果为List的话，只需要指明list中泛型的类型 ​ ·当输出类型为javabean类型时，需要写类所在的完整路径com.xxx.xxx.xx；为了书写方便，也可以指定它的别名，如上面一般。指定别名有三种方式： 123456&lt;typeAliases&gt; &lt;!--配置实体类别名：包扫描 默认别名是类名--&gt; &lt;package name="com.shsxt.po"/&gt; &lt;!--typeAlias标签指定路径--&gt; &lt;typeAlias type="com.shsxt.po.User" alias="user"/&gt; &lt;/typeAliases&gt; ​ 还可以把typeAlias中的alias标签以注解的方式写在javabean类的上面 ​ 和原生jdbc不同的是，原生jdbc的占位符’?’，在这里用#{传入参数的名字} ​ 基本配置就基本完成了，接下来就是调用了，从这里可以看出，mybatis环境中需要配置输入参数类型，输出参数类型和sql语句就可以完成数据库操作。 ​ 那我们知道数据库中一部分字段的类型和java中是不同的，比如数据库中的varchar，在java中是String，它是用什么转换的呢—-&gt;typeHandler类型处理器，在预处理语句中设置一个参数或者获取一个参数时，类型处理器都会将获取到的值以合适的方式转换为java类型 ​ 调用，实现一个查询其中主要过程 （1）读取资源文件 （2）创建sqlsession工厂 （3）由sqlsession工厂打开/创建session （4）通过session操作数据库 （5）处理结果 （6）关闭sqlsession 我在这里将映射文件对应了一个接口，实现了这个接口并且做了一些封装 12345678910111213141516171819202122232425262728public class UserMapperImpl implements UserMapper &#123; private SqlSessionFactory sqlSessionFactory; private static SqlSession sqlSession; public UserMapperImpl() &#123; &#125; public UserMapperImpl(SqlSessionFactory sqlSessionFactory) &#123; this.sqlSessionFactory = sqlSessionFactory; sqlSession = sqlSessionFactory.openSession(); &#125; @Override public List&lt;User&gt; queryUserByName(String userName) &#123; List&lt;User&gt; users = null; try &#123; users = sqlSession.selectList("com.shsxt.mapper.UserMapper.queryUserByName", userName); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (sqlSession != null) &#123; sqlSession.close(); &#125; &#125; return users; &#125;&#125; 单元测试代码 1234567891011121314151617public class Test01 &#123; private SqlSessionFactory sqlSessionFactory; private static UserMapper userMapper; @Before public void before() throws IOException &#123; InputStream is = Resources.getResourceAsStream("mybatis.xml"); sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); &#125; @Test public void test01() &#123; userMapper = new UserMapperImpl(sqlSessionFactory); List&lt;User&gt; users = userMapper.queryUserByName("z"); for (User user : users) System.out.println(user); &#125;&#125; 结果 因为使用了log4j日志采集，可以看到我们编写的sql还有查询到的总数量]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Ajax轮询和长轮询]]></title>
    <url>%2Fdlh1234okok.github.io%2F2018%2F10%2F07%2FAjax%E8%BD%AE%E8%AF%A2%E5%92%8C%E9%95%BF%E8%BD%AE%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[​ 在需要实时信息更新的时候，可以使用轮询不断向服务器请求获取数据，但是频繁请求服务器，效率低而且十分耗费资源，一般推荐使用webSocket建立持久连接 ​ 因为以前没有听说过这个名词，现在了解后在这里做一个备份（这里只贴出代码） 12345678910111213// Ajax轮询 var get = &#123; url:"user", type:"post", dataType:"json", success:function (data) &#123; console.log("next"); &#125; &#125;; // Ajax定时访问服务端，不断建立连接获取数据 window.setInterval(function () &#123; $.ajax(get) &#125;,1000); 1234567891011121314// Ajax长轮询 var get = &#123; url:"user", type:"post", dataType:"json", success:function (data) &#123; $.ajax(get); // 在Ajax的回调函数这里再次发送ajax请求 &#125;, error:function () &#123; $.ajax(get); // 当请求时间过长，再次调用ajax长轮询 &#125; &#125;; $.ajax(get); 在一次请求完成返回之后立刻再次发送请求，当没有数据就会被挂在服务器，但只要有数据就会返回。]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[webSocket学习(1)]]></title>
    <url>%2Fdlh1234okok.github.io%2F2018%2F10%2F07%2FwebSocket%E5%AD%A6%E4%B9%A0-1%2F</url>
    <content type="text"><![CDATA[一、webSocket是什么 ​ webSocket是html5推出的一种新协议，和HTTP协议基本没有关系，但是为了兼容现有浏览器的握手规范，需要通过HTTP协议完成一部分握手，也可以说是HTTP协议的补充，两者之间有交集，但不是全部，可以用以下这张图理解HTTP和webSocket的关系 二、为什么需要webSocket ​ HTTP协议是无状态（协议对事务处理没有记忆能力），无连接（一次请求即断开连接），单向的应用层协议（只能由客户端请求服务器，服务器无法主动向客户端发送消息）。 ​ 在这种单向请求的特点在服务器状态持续发生变化时客户端想要获知就很麻烦，（可以使用Ajax的轮询或者长轮询实现），但是轮询效率低并且十分耗费资源（因为要持续不断的打开连接） ​ 在这种情况下，webSocket应运而生了，webSocket只需要建立一次连接就可以保持连接，进行持久通信，而且客户端和服务端都可以通过连接发送数据到另一方。 ​ 在需要实时通信的需求下使用webSocket最好不过了 对于webSocket的介绍就到这里，贴一篇关于webSocket原理的文章参考 https://www.cnblogs.com/fuqiang88/p/5956363.html 三、通过Java实现webSocket通信的简易聊天室 js代码（客户端） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;主页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="text" id="userMsg"/&gt;&lt;button onclick="send()"&gt;发送消息&lt;/button&gt;&lt;/br&gt;&lt;button onclick="closeWebSocket()"&gt;关闭连接&lt;/button&gt;&lt;button onclick="clearMsg()"&gt;清屏&lt;/button&gt;&lt;div id="msg"&gt;&lt;/div&gt;&lt;div id="per"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script type="text/javascript" src="statics/jquery-3.3.1.min.js"&gt;&lt;/script&gt;&lt;%String nick = request.getParameter("nick");%&gt;&lt;script type="text/javascript"&gt; // 页面加载完毕没有登录则跳转到登录页面 $(function () &#123; var nick = &lt;%=nick%&gt;; if (nick==null)&#123; window.location.href="login.jsp"; &#125; &#125;); var webSocket = null; // 判断浏览器是否支持webSocket if ("WebSocket" in window)&#123; webSocket = new WebSocket("ws://192.168.1.139:8080/chat"); &#125;else&#123; alert("浏览器不支持webSocket") &#125; // 连接发生错误的回调方法 webSocket.onerror = function () &#123; setMsg("发生错误") &#125;; // 建立连接后要做的事情 webSocket.onopen = function () &#123; addUser(); &#125;; // 服务器发送过来的消息 webSocket.onmessage = function (event) &#123; setMsg(event.data); &#125;; // 关闭连接 webSocket.onclose = function () &#123; subUser(); &#125;; // 当浏览器关闭时关闭连接，防止后台报错 window.onbeforeunload = function () &#123; closeWebSocket(); &#125;; // 将信息显示在页面 function setMsg(msg)&#123; $('#msg').append(msg+"&lt;/br&gt;"); &#125; function addUser() &#123; webSocket.send('&lt;%=nick%&gt;'+"加入聊天室"); &#125; function subUser() &#123; webSocket.send('&lt;%=nick%&gt;'+"离开聊天室"); &#125; // 关闭webSocket连接 function closeWebSocket() &#123; webSocket.close(); window.location.href="login.jsp"; &#125; // 发送消息 function send() &#123; var userMsg= $('#userMsg').val(); webSocket.send('&lt;%=nick%&gt;'+"说："+userMsg); $('#userMsg').val(""); &#125; function clearMsg() &#123; $('#msg').empty(); &#125;&lt;/script&gt;&lt;/html&gt; java代码（服务端） ​ 在编写代码之前需要引入javaee标准 123456&lt;dependency&gt; &lt;groupId&gt;javax&lt;/groupId&gt; &lt;artifactId&gt;javaee-api&lt;/artifactId&gt; &lt;version&gt;7.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.shsxt.websocket;import javax.websocket.*;import javax.websocket.server.ServerEndpoint;import java.io.IOException;import java.util.concurrent.CopyOnWriteArraySet;// 建立一个webSocket的端点，要和js代码中对应@ServerEndpoint("/chat")public class ChatServer &#123; // 与客户端之间连接的会话，通过session向和客户端发送消息 private Session session; // concurrent包线程安全的set，用来存放chatServer对象 private static CopyOnWriteArraySet&lt;ChatServer&gt; set = new CopyOnWriteArraySet&lt;&gt;(); // 用来计算当前在线人数 private Integer onlineNum = 0; /** * 建立连接后要做的事情 */ @OnOpen public void onOpen(Session session)&#123; this.session = session; set.add(this); //将当前登录对象放入集合 System.out.println("webSocket连接已经建立.."); addOnline(); &#125; /** * 从客户端收到的消息 */ @OnMessage public void onMessage(String msg,Session session)&#123; this.session = session; try &#123; for (ChatServer chats:set)&#123; chats.session.getBasicRemote().sendText(msg); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** * 断开连接 */ @OnClose public void onClose(Session session)&#123; set.remove(this); System.out.println("断开连接..."); subOnline(); &#125; /** * 发生异常调用 */ @OnError public void onError(Throwable e)&#123; System.out.println("发生异常..."); e.printStackTrace(); &#125; public synchronized void addOnline()&#123; onlineNum++; &#125; public synchronized void subOnline()&#123; onlineNum--; &#125; // 获取在线人数 public synchronized Integer getOnline()&#123; return onlineNum; &#125;&#125; 以上内容大部分源于网络]]></content>
      <categories>
        <category>webSocket</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JS原生Ajax]]></title>
    <url>%2Fdlh1234okok.github.io%2F2018%2F10%2F04%2FJS%E5%8E%9F%E7%94%9FAjax%2F</url>
    <content type="text"><![CDATA[一、XMLHTTPRequest Ajax技术核心是XMLHTTPRequest对象（简称XHR），是由微软首先引入的一个特性，其他浏览器提供商后来都提供了相同的实现。在XHR出现之前，Ajax式的通信必须借助一些手段来实现，大多数是使用隐藏的框架或内嵌框架。 Ajax，是Asynchronout JavaScript+XML的简写。这种技术能够向服务器请求额外的数据而无需卸载/刷新页面，会带来更好的用户体验。 1、支持原生XHR对象的浏览器创建XHR对象可以直接实例化XMLHTTPRequest。 2、在使用XHR对象时，先必须调用open()方法，它接收三个参数：要发送的请求类型（get/post）、请求的URL和表示是否异步(async)。open()方法并不会真正发送请求，而只是启动一个请求以备发送。 3、通过send()方法进行发送请求，send()方法接受一个参数，作为请求主体发送的数据。如果不需要必须填null。执行send()方法后请求就会发送到服务器上。 4、请求发送到服务端收到响应后，响应的数据会自动填充XHR对象的属性，一共有四个属性： &nbsp; 5、接受响应之后，第一步检查status属性，以确定响应已经成功返回，有如下的状态代码： 6、判断http状态值以确定响应是否成功返回 7、当使用异步调用的时候，检测readyState属性，每当readyState属性改变时，触发readyStatechange事件。这个属性共有五个值： &nbsp;&nbsp;二、GET与POST 1、GET请求 通过URL后的问号给服务器传递键值对数据，服务器接收到返回响应数据。特殊字符传参产生的问题可以使用encodeURIComponent()进行编码处理，中文字符的返回及传参，可以将页面保存和设置为utf-8即可，AJAX返回的数据为UTF-8。 2、POST请求 通过发送POST请求的数据，不会跟在URL后面，而是通过send()方法向服务器提交数据 &nbsp; 向服务器发送POST请求由于解析机制的原因，需要进行特别的处理。因为POST请求和Web表单提交是不同的的，需要使用XHR来模仿表单提交。 从性能上来讲POST请求比GET请求消耗更多一些，用相同数据比较，GET请求最多比POST请求快两倍&nbsp;三、封装Ajax&lt;script type=”text/javascript”&gt;var obj={ url:“user”, method:“post”, data:{name:“zs”,age:18}, async:true, success:function(result){ console.log(result); console.log(JSON.parse(result)) }, error:function(result){ console.log(result); }}ajax(obj)function ajax(obj){​ //得到XMLHTTPRequest对象​ var xhr=new XMLHttpRequest();​ //将参数格式化​ obj.data=params(obj.data);​ //判断请求方式​ if(obj.method.toUpperCase()==”GET”){​ obj.url+=(obj.url.indexOf(“?”)==-1)?”?”+obj.data:”&amp;”+obj.data;​ //open()方法：请求方式/请求路径/是否异步 xhr.open(obj.method,obj.url,obj.async);​ //发送请求​ xhr.send(null);​ }else{ // POST请求 xhr.open(obj.method,obj.url,obj.async);​ //模拟表单提交​ xhr.setRequestHeader(“Content-Type”,”application/x-www-form-urlencode”);​ //发送请求 xhr.send(obj.data);​ }​ //判断是否是异步请求​ if(obj.async){ //异步请求​ //判断响应是否完全响应​ xhr.onreadystatechange=function(){​ if(xhr.readyState==4){​ callback();​ }​ }​ }else{​ callback();​ } //回调函数 function callback(){ if(xhr.status==200){ //回调函数 obj.success(xhr.responseText);​ }else{​ obj.error(“请求失败！错误状态码”+xhr.status+”,错误原因”+xhr.statusText);​ }​ }}/ 将json格式的字符串转换成普通的参数拼接 / function params(data){ var arr=[]; if(data!=null &amp;&amp; data !=””){ ​ for(var d in data){ ​ console.log(d+” “+data[d]); ​ var name=encodeURIComponent(d); ​ var value=encodeURIComponent(data[d]); arr.push(name+”=”+value); } var param=arr.join(“&amp;”); return param; } return null; } &lt;/script&gt; &nbsp; &nbsp;同步： 提交请求–&gt;等待服务器处理–&gt;处理完毕返回这个期间客户端浏览器不能干的事，当前只能做一件事。 异步： 请求通过事件触发–&gt;服务器处理（这时浏览器仍然可以做其他事情）–&gt;处理完毕。可以同时做多件事情&nbsp;四、JQuery封装的AJax $.ajax(){} $.get(){} $.getJson(){} $.post(){}]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Spring-IoC]]></title>
    <url>%2Fdlh1234okok.github.io%2F2018%2F10%2F04%2FSpring-IoC%2F</url>
    <content type="text"><![CDATA[一、Spring框架概念 spring 是众多开源 java 项目中的一员，基于分层的 javaEE 应用一站式轻量级开源框架，主要核心是 Ioc(控制反转/依赖注入) 与 Aop(面向切面)两大技术，实现项目在开发过程中的轻松解耦， 提高项目的开发效率。 在项目中引入spring的好处： &middot;降低组件之间的耦合度，实现软件各层之间的解耦 &middot;可以使用容器提供的众多服务，如：事务管理服务、消息服务等 &middot;当使用容器管理事务时，开发人员就不需要手工控制事务，也不需要处理复杂的事务传播 &middot;容器提供单例模式支持，开发人员不再需要自己编写实现代码 &middot;容器提供了AOP技术，利用它很容易实现如权限拦截、运行期监控等功能 &nbsp; 二、Spring源码架构 1、核心容器:spring-beans 和 spring-core 模块是 Spring 框架的核心模块，包含控制反转（Inversion of Control, IoC）和依赖注入（Dependency Injection, DI） ,核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory， 工厂模式的实现。 BeanFactory 使用控制反转（IOC） 思想将应用程序的配置和依赖性规范与实际的应用程序代码分开。 2、Spring 上下文 Spring Context： Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。 Spring 上下文包括企业服务，例如 JNDI、 EJB、电子邮件、国际化、校验和调度功能。 3、Spring-Expression 模块是统一表达式语言（unified EL）的扩展模块，可以查询、管理运行中的对象，同时也方便的可以调用对象方法、操作数组、集合等。它的语法类似于传统 EL，但提供了额外的功能，最出色的要数函数调用和简单字符串的模板函数。 4、Spring-AOP： spring-aop 是 Spring 的另一个核心模块, 在 Spring中，他是以 JVM 的动态代理技术为基础，然后设计出了一系列的Aop 横切实现，比如前置通知、返回通知、异常通知等。 通过其配置管理特性， Spring AOP 模块直接将面向切面的编程功能集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理的任何对象支持 AOP。 …… &nbsp;三、Spring容器工厂的简单实现 import org.dom4j.Document;import org.dom4j.DocumentException;import org.dom4j.Element;import org.dom4j.XPath;import org.dom4j.io.SAXReader; import java.lang.reflect.Method;import java.net.URL;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map; public class Factory_01 implements Factory {​ // Map集合用来存放id和class​ Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();​ List&lt;Bean&gt; beans = new ArrayList&lt;&gt;(); &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt; 实例化工厂对象时就完成以下操作&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;public&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; Factory_01(String fileName) { &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt; xml解析&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;this&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;.pathXml(fileName); &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt; 实例化对象&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;this&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;.instanceBean(); &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt; 属性赋值&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;this&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;.setProperty(); } &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt; 属性赋值&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;private&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;void&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; setProperty() { &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;try&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; { &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt;(&lt;span style=&quot;color: #0000ff;&quot;&gt;null&lt;/span&gt;!=beans &amp;amp;&amp;amp; beans.size()&amp;gt;0&lt;span style=&quot;color: #000000;&quot;&gt;){ &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;for&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;(Bean bean:beans){ List&lt;/span&gt;&amp;lt;Property&amp;gt; properties=&lt;span style=&quot;color: #000000;&quot;&gt;bean.getProperties(); &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt;(&lt;span style=&quot;color: #0000ff;&quot;&gt;null&lt;/span&gt;!=properties &amp;amp;&amp;amp; properties.size()&amp;gt;0&lt;span style=&quot;color: #000000;&quot;&gt;){ &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;for&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;(Property property:properties){ &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt; 得到property的id和ref&lt;/span&gt; String id=&lt;span style=&quot;color: #000000;&quot;&gt;property.getId(); String ref&lt;/span&gt;=&lt;span style=&quot;color: #000000;&quot;&gt;property.getRef(); &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt; set方法中首字母大写&lt;/span&gt; id=id.toUpperCase().charAt(0)+id.substring(1&lt;span style=&quot;color: #000000;&quot;&gt;); &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt; 获取到当前class&lt;/span&gt; Class clz=&lt;span style=&quot;color: #000000;&quot;&gt;map.get(bean.getId()).getClass(); &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt; 找到set方法&lt;/span&gt; Method method=clz.getDeclaredMethod(&quot;set&quot;+&lt;span style=&quot;color: #000000;&quot;&gt;id,map.get(ref).getClass()); method.invoke(map.get(bean.getId()),map.get(ref)); } } } } } &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;catch&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; (Exception e) { e.printStackTrace(); } } &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt; 实例化&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;private&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;void&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; instanceBean() { &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt; (&lt;span style=&quot;color: #0000ff;&quot;&gt;null&lt;/span&gt; != beans &amp;amp;&amp;amp; beans.size() &amp;gt; 0&lt;span style=&quot;color: #000000;&quot;&gt;) { &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;try&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; { &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;for&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; (Bean bean : beans) { &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt; 放到map集合中，通过key找到value，实例化该对象&lt;/span&gt; map.put(bean.getId(), Class.forName(bean.getClz()).newInstance());​ }​ } catch (ClassNotFoundException e) {​ e.printStackTrace();​ } catch (IllegalAccessException e) {​ e.printStackTrace();​ } catch (InstantiationException e) {​ e.printStackTrace();​ } } } &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;/**&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt; * xml解析 * * &lt;/span&gt;&lt;span style=&quot;color: #808080;&quot;&gt;@param&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt; fileName xml文件名 &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;*/&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;private&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;void&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; pathXml(String fileName) { &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt; 获取xml文件&lt;/span&gt; URL url = &lt;span style=&quot;color: #0000ff;&quot;&gt;this&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;.getClass().getClassLoader().getResource(fileName); &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;try&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; { &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt; (&lt;span style=&quot;color: #0000ff;&quot;&gt;null&lt;/span&gt; !=&lt;span style=&quot;color: #000000;&quot;&gt; url) { &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt; 获取解析器&lt;/span&gt; SAXReader saxReader = &lt;span style=&quot;color: #0000ff;&quot;&gt;new&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; SAXReader(); &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt; 解析xml文件，返回document对象&lt;/span&gt; Document document =&lt;span style=&quot;color: #000000;&quot;&gt; saxReader.read(url); &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt; 获取xpath对象&lt;/span&gt; XPath xPath = document.createXPath(&quot;beans/bean&quot;&lt;span style=&quot;color: #000000;&quot;&gt;); &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt; 查询选择的节点，返回的是list集合&lt;/span&gt; List&amp;lt;Element&amp;gt; elements =&lt;span style=&quot;color: #000000;&quot;&gt; xPath.selectNodes(document); &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt; 为空判断&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt; (&lt;span style=&quot;color: #0000ff;&quot;&gt;null&lt;/span&gt; != elements &amp;amp;&amp;amp; elements.size() &amp;gt; 0&lt;span style=&quot;color: #000000;&quot;&gt;) { &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;for&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; (Element element : elements) { &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt; 获取property&lt;/span&gt; xPath = document.createXPath(&quot;property&quot;&lt;span style=&quot;color: #000000;&quot;&gt;); &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt; 查询选择的节点&lt;/span&gt; List&amp;lt;Element&amp;gt; subElements =&lt;span style=&quot;color: #000000;&quot;&gt; xPath.selectNodes(element); &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt; 为空判断&lt;/span&gt; List&amp;lt;Property&amp;gt; properties = &lt;span style=&quot;color: #0000ff;&quot;&gt;null&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;; &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt; 实例化Bean&lt;/span&gt; Bean bean = &lt;span style=&quot;color: #0000ff;&quot;&gt;new&lt;/span&gt; Bean(element.attributeValue(&quot;id&quot;), element.attributeValue(&quot;class&quot;&lt;span style=&quot;color: #000000;&quot;&gt;)); &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt; (&lt;span style=&quot;color: #0000ff;&quot;&gt;null&lt;/span&gt; != subElements &amp;amp;&amp;amp; subElements.size() &amp;gt; 0&lt;span style=&quot;color: #000000;&quot;&gt;) { properties &lt;/span&gt;= &lt;span style=&quot;color: #0000ff;&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span style=&quot;color: #000000;&quot;&gt;(); &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;for&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; (Element subElement : subElements) { &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt; 实例化Property&lt;/span&gt; Property property = &lt;span style=&quot;color: #0000ff;&quot;&gt;new&lt;/span&gt; Property(subElement.attributeValue(&quot;id&quot;), subElement.attributeValue(&quot;ref&quot;&lt;span style=&quot;color: #000000;&quot;&gt;)); &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt; 将对象放到集合中&lt;/span&gt; properties.add(property);​ }​ bean.setProperties(properties);​ }​ beans.add(bean);​ }​ }​ }​ } catch (DocumentException e) {​ e.printStackTrace();​ }​ } @Override &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;public&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; Object getObj(String name) { &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt; 通过id返回class&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;return&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; map.get(name); } }View Code &nbsp; 四、Spring多文件的加载情况 1、ClassPathXmlApplicationContext类的构造器参数是一个可变长参数 可同时配置多个xml文件 2、import标签，将自配置文件导入总配置 &nbsp; 四、Spring Ioc实例化bean的三种方式 1、构造器的方式实例化bean对象 通过默认构造器实例化bean对象，默认空构造器必须存在 &nbsp; 2、静态工厂方式实例化bean 要有工厂类和静态工厂方法 通过反射调用静态工厂的静态方法，将该静态方法的返回值作为bean的实例，可以统一管理各个bean的创建 &nbsp; &nbsp; 3、实例化工厂方式实例化bean 工厂类和实例化方法 工厂方法为非静态，需要配置工厂bean，并在bean中配置factory-bean和factory-method属性 1) 可用于集成其他框架的bean创建管理方法&nbsp; 2)能够使bean和factory的角色互换 &nbsp; 五、Spring 依赖注入 在面向接口编程中，依赖接口可以动态传入多种实现 1、set注入 property标签，属性的set方法（不会出现循环引用问题） name：属性名称；ref：bean对象的引用；value：给属性直接赋值（List，Set，Map，properties） 2、构造器注入 constructor-arg标签，带参构造器（会出现循环引用问题，彼此互相依赖对方导致bean无法实例化） name：属性名称；ref：bean对象id的引用；index：属性的索引 &nbsp; 3、静态工厂注入 &nbsp; 4、实例化工厂注入 &nbsp; 六、注解方式注入bean xml配置：加入context命名空间和xsd地址 添加&lt;context:annotation-config/&gt;配置 &nbsp; @Resource （属于J2EE） @Autowired （Spring） 常用于属性字段或set方法上 区别： @Autowired 默认按bean的类型匹配，和@Qualifier配合使用可以修改按名称匹配 @Resource 默认按名称进行装配，可以通过name属性指定，如果没有指定name属性，当注解写在字段上时，默认取字段名进行匹配注入，如果注解写在set方法上默认取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配（当name属性指定，只会按照名称装配） &nbsp; 注解方式注入的简单模拟： import com.shsxt.annotaioms.Component;import com.shsxt.annotaioms.Component02;import com.shsxt02.controller.UserController; import java.io.File;import java.lang.reflect.Field;import java.net.URL;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map; public class Test { &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;private&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;static&lt;/span&gt; List&amp;lt;String&amp;gt; clz=&lt;span style=&quot;color: #0000ff;&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span style=&quot;color: #000000;&quot;&gt;(); &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;private&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;static&lt;/span&gt; Map&amp;lt;String,Object&amp;gt; map=&lt;span style=&quot;color: #0000ff;&quot;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span style=&quot;color: #000000;&quot;&gt;(); &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;public&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;static&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;void&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; main(String[] args){ String pkg&lt;/span&gt;=&quot;com.shsxt02&quot;&lt;span style=&quot;color: #000000;&quot;&gt;; &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt; 获取标记注解的类&lt;/span&gt; getClZ(pkg);​ // 实例化这些类 instanceClz();​ // 属性赋值 property();​ UserController userController= (UserController) map.get(“userController”);​ userController.test();​ } &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;private&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;static&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;void&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; property() { &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;try&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; { &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt; (&lt;span style=&quot;color: #0000ff;&quot;&gt;null&lt;/span&gt;!=&lt;span style=&quot;color: #000000;&quot;&gt;map){ &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;for&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;(Map.Entry entry:map.entrySet()){ Field[] fields&lt;/span&gt;=&lt;span style=&quot;color: #000000;&quot;&gt;entry.getValue().getClass().getDeclaredFields(); &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt; (&lt;span style=&quot;color: #0000ff;&quot;&gt;null&lt;/span&gt;!=&lt;span style=&quot;color: #000000;&quot;&gt;fields){ &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;for&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;(Field field:fields){ Component02 component02&lt;/span&gt;=field.getAnnotation(Component02.&lt;span style=&quot;color: #0000ff;&quot;&gt;class&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;); &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt; (&lt;span style=&quot;color: #0000ff;&quot;&gt;null&lt;/span&gt;!=&lt;span style=&quot;color: #000000;&quot;&gt;component02){ field.setAccessible(&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;true&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;); field.set(entry.getValue(),map.get(component02.value())); } } } } } } &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;catch&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; (IllegalAccessException e) { e.printStackTrace(); } } &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;private&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;static&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;void&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; instanceClz() { &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;try&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; { &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt; (&lt;span style=&quot;color: #0000ff;&quot;&gt;null&lt;/span&gt;!=clz &amp;amp;&amp;amp; clz.size()&amp;gt;0&lt;span style=&quot;color: #000000;&quot;&gt;){ &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;for&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;(String cls:clz){ &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;System.out.println(str);&lt;/span&gt; cls=cls.replace(&quot;.class&quot;,&quot;&quot;&lt;span style=&quot;color: #000000;&quot;&gt;); &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;System.out.println(cls);&lt;/span&gt; Component component=Class.forName(cls).getAnnotation(Component.&lt;span style=&quot;color: #0000ff;&quot;&gt;class&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;); &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt; (&lt;span style=&quot;color: #0000ff;&quot;&gt;null&lt;/span&gt;!=&lt;span style=&quot;color: #000000;&quot;&gt;component){ &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;System.out.println(cls);&lt;/span&gt; String id=&lt;span style=&quot;color: #000000;&quot;&gt; getId(cls); Object obj&lt;/span&gt;=&lt;span style=&quot;color: #000000;&quot;&gt;Class.forName(cls).newInstance(); map.put(id,obj); } } } } &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;catch&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; (ClassNotFoundException e) { e.printStackTrace(); } &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;catch&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; (IllegalAccessException e) { e.printStackTrace(); } &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;catch&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; (InstantiationException e) { e.printStackTrace(); } } &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;private&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;static&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; String getId(String cls) { cls&lt;/span&gt;=cls.substring(cls.lastIndexOf(&quot;.&quot;)+1&lt;span style=&quot;color: #000000;&quot;&gt;); cls&lt;/span&gt;= cls.toLowerCase().charAt(0)+cls.substring(1&lt;span style=&quot;color: #000000;&quot;&gt;); &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;return&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; cls; } &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;private&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;static&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;void&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; getClZ(String pkg) { &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt; 获取url&lt;/span&gt; URL url=&lt;span style=&quot;color: #000000;&quot;&gt;Thread.currentThread().getContextClassLoader().getResource(repStr(pkg)); String urlPath&lt;/span&gt;=&lt;span style=&quot;color: #000000;&quot;&gt;url.getFile(); &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;System.out.println(urlPath);&lt;/span&gt; String[] subFileStrs=&lt;span style=&quot;color: #0000ff;&quot;&gt;new&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; File(urlPath).list(); &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;for&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;(String str:subFileStrs){ String subFilePath&lt;/span&gt;=urlPath+&quot;/&quot;+&lt;span style=&quot;color: #000000;&quot;&gt;str; &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;System.out.println(subFilePath);&lt;/span&gt; File subFile=&lt;span style=&quot;color: #0000ff;&quot;&gt;new&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; File(subFilePath); &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; (subFile.isDirectory()){ &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;System.out.println(pkg+&quot;.&quot;+subFile.getName());&lt;/span&gt; getClZ(pkg+&quot;.&quot;+&lt;span style=&quot;color: #000000;&quot;&gt;subFile.getName()); }&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;else&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;{ clz.add(pkg&lt;/span&gt;+&quot;.&quot;+&lt;span style=&quot;color: #000000;&quot;&gt;subFile.getName()); } } } &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;private&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;static&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; String repStr(String str){ str&lt;/span&gt;=str.replace(&quot;.&quot;,&quot;/&quot;&lt;span style=&quot;color: #000000;&quot;&gt;); &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;return&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; str; } } &nbsp; 七、Spring IOC 容器自动扫描管理bean xml配置&lt;context:component-scan base-package=””/&gt; 建议的注解 Dao层：@Repository Service层：@Service 控制层：@Controller 不明确：@Component &nbsp; 八、Bean的作用域问题(scope) 1、singleton作用域（单例，默认） lazy-init 懒加载 默认为false 如果等于true时，spring容器启动的时候不会去实例化这个bean，而是在程序调用时才会去实例化 在启动情况下实例化所有singleton的bean对象并缓存与容器中单例的好处： 1、提前发现潜在的配置问题 2、bean对象存在于缓存中，使用时不用再实例化bean，提高执行性能 无状态对象适合做单例bean对象（无可变的成员变量） &nbsp; 2、prototype作用域（原型） 每次向Spring容器请求获取Bean都返回一个全新的Bean，相对于&ldquo;singleton&rdquo;来说就是不缓存Bean。IOC不会维护该对象 &nbsp; 3、Web应用中的作用域（request、session、globalsession） request作用域：每一次请求 session：当前会话 globlasession：同session（Portlet环境）]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Spring-AOP]]></title>
    <url>%2Fdlh1234okok.github.io%2F2018%2F10%2F04%2FSpring-AOP%2F</url>
    <content type="text"><![CDATA[一、代理模式 1、代理模式的设计原则： &middot;代理类与委托类具有相似的行为 &middot;代理类增强委托类的行为 2、代理模式实现的三要素： 代理角色、目标角色、共同行为 实现行为接口，持有目标对象的引用 &nbsp; 3、静态代理和动态代理 1）静态代理 特点：程序运行前制作代理角色 代理目标角色单一 代理类数量无法控制 2）动态代理 程序运行期动态创建代理角色 &middot;JDK动态代理，回调方式实现 &middot;cglib动态代理，继承方式实现 区别： JDK动态代理：委托类必须要有接口，制作过程较快，执行慢 Cglib动态代理：委托类可以没有接口，继承的思维来实现相似性，制作代理过程比较慢，执行快 &nbsp; 二、AOP（面相切面编程） AOP的两种实现机制是JDK动态代理和cglib动态代理 AOP主要应用于日志记录，性能统计，安全控制，事务处理额等方面，实现公共行为的重复使用 降低模块之间的耦合度，提高业务代码的聚合度（高内聚低耦合） 提高代码的复用性 提高系统的扩展性 Aop基本概念 Joinpoint（连接点）：spring中指被拦截到的每一个方法 Pointcut（切入点）：规定拦截哪些方法，对那些方法进行处理 Advice（通知）：拦截到每一个连接点后要做的操作 前置通知、返回通知、最终通知、异常通知、环绕通知 Aspect（切面）：切入点与通知的结合 Target（目标对象）：被代理的目标对象 Weave（织入） Introduction（引入） &nbsp; 三、AOP注解实现 1、XML：引入命名空间，开启aop代理环境 2、Maven项目引入Aspect坐标 3、创建切面类 @Aspect定义切面类 4、声明方法为切入点 @Pointcut 匹配规则定义 execution 5、创建通知方法 package com.shsxt02.proxy;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.;import org.springframework.stereotype.Component;@Aspect@Componentpublic class LogCut { @Pointcut(“execution( com.shsxt02.service...(..))”) public void cut() { } @After(value = “cut()”) public void before(){ System.out.println(“前置通知，目标方法执行前执行…”); } @AfterReturning(value = “cut()”) public void afterReturn(){ System.out.println(“返回通知，方法正常结束后执行…”); } @After(value = “cut()”) public void after(){ System.out.println(“最终通知，方法是否发生异常均会执行…”); } @AfterThrowing(value = “cut()”,throwing = “e”) public void afterThrow(Exception e){ System.out.println(“异常通知，异常时执行…”+e); } // 环绕通知 @Around(value = “cut()”) public Object around(ProceedingJoinPoint pjp) throws Throwable { Object result=null; System.out.println(“环绕前置…”); System.out.println(“环绕通知…”); System.out.println(“方法签名”+pjp.getSignature()); System.out.println(“目标对象”+pjp.getTarget()); System.out.println(“种类”+pjp.getKind()); Object[] objects=pjp.getArgs(); for(Object o:objects){ System.out.println(“参数”+o); } result= pjp.proceed(); // 返回的目标对象 System.out.println(“环绕后置…”); return result; }} &nbsp; 四、AOP XML配置实现 &nbsp; &nbsp; 五、AOP拦截注释 &nbsp; 如果目标角色实现了接口，AOP有代理，返回的是代理对象，需要通过接口接收。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Spring-定时器和邮件发送]]></title>
    <url>%2Fdlh1234okok.github.io%2F2018%2F10%2F04%2FSpring-%E5%AE%9A%E6%97%B6%E5%99%A8%E5%92%8C%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81%2F</url>
    <content type="text"><![CDATA[一、定时器的实现（task） 1、在XML配置文件中引入约束 xmlns:task=”http://www.springframework.org/schema/task&quot; http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task.xsd 2、编写定时器类，和方法 &nbsp; 3、使用xml配置文件 加载配置文件就可以执行定时任务了，图为两秒执行一次。 &nbsp; 二、邮件发送 1、Java mail发送邮件 1) Maven项目引入java mail坐标，也可以手动安装 package com.shsxt.service;import org.apache.commons.lang3.StringUtils;import javax.activation.DataHandler;import javax.activation.DataSource;import javax.activation.FileDataSource;import javax.mail.;import javax.mail.internet.;import java.io.File;import java.io.UnsupportedEncodingException;import java.nio.charset.Charset;import java.util.Properties;public class MailService { public void mail(String fromUser, String[] receivers, String setSubject, String content, String[] files) { // 判断参数是否为空 if (!judgment(fromUser, receivers, setSubject, content)){ return; } // 获取session Session session = init(fromUser); Message message = new MimeMessage(session); // 发送人 sender(fromUser, message);​ // 收件人 recipients(receivers, message);​ // 主题 subject(message,setSubject);​ // 设置html和附件​ Multipart multipart = new MimeMultipart();​ // html内容 Content(content, multipart);​ // 判断是否有附件​ if (null != files &amp;&amp; files.length &gt; 0) {​ // 上传附件 fileUp(files, multipart);​ }​ settingContext(message, multipart);​ // 发送 send(message);​ } // 8、发送 private void send(Message message) { try { Transport.send(message); } catch (MessagingException e) { e.printStackTrace(); } } // 7、设置上下文 private void settingContext(Message message, Multipart multipart) { try { message.setContent(multipart); } catch (MessagingException e) { e.printStackTrace(); } } // 6、设置主题 private void subject(Message message,String setSubject) { try { message.setSubject(setSubject); } catch (MessagingException e) { e.printStackTrace(); } } // 5、上传附件 private void fileUp(String[] files, Multipart multipart) { try { for (String filePath : files) { BodyPart file = new MimeBodyPart(); File temp = new File(filePath); file.setDataHandler(new DataHandler(new FileDataSource(new File(filePath)))); file.setFileName(MimeUtility.encodeText(temp.getName())); multipart.addBodyPart(file); } } catch (Exception e) { e.printStackTrace(); } } // 4、设置html内容 private void Content(String content, Multipart multipart) { try { BodyPart html = new MimeBodyPart(); html.setContent(content, “text/html;charset=utf-8”); multipart.addBodyPart(html); } catch (MessagingException e) { e.printStackTrace(); } } // 3、设置收件人 private void recipients(String[] receivers, Message message) { try { Address[] addresses = new InternetAddress[receivers.length]; for (int i = 0; i &lt; addresses.length; i++) { addresses[i] = new InternetAddress(receivers[i]); } message.setRecipients(Message.RecipientType.TO, addresses); } catch (MessagingException e) { e.printStackTrace(); } } // 2、设置发送人 private void sender(String fromUser, Message message) { try { Address from = new InternetAddress(fromUser); message.setFrom(from); } catch (Exception e) { e.printStackTrace(); } } // 1、初始化 private Session init(String fromUser) { Properties properties = new Properties(); // 邮箱服务器主机 properties.put(“mail.smtp.host”, “smtp.163.com”); properties.put(“mail.smtp.auth”, “true”); properties.put(“mail.smtp.port”, 25); Session session = Session.getDefaultInstance(properties, new Authenticator() { @Override protected PasswordAuthentication getPasswordAuthentication() { return new PasswordAuthentication(“15657262398@163.com“, “d140120”); } }); return session; } // 0、判断参数是否为空 private boolean judgment(String fromUser, String[] receivers, String setSubject, String content) { boolean flag = true; if (StringUtils.isBlank(fromUser) || StringUtils.isAnyBlank(receivers) || StringUtils.isBlank(setSubject) || StringUtils.isBlank(content)) { flag = false; } return flag; }} &nbsp; 2、spring环境下发送邮件 XML配置 &lt;?xml version=”1.0” encoding=”UTF-8”?&gt;&lt;beans xmlns=”http://www.springframework.org/schema/beans&quot; xmlns:xsi=”http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=”http://www.springframework.org/schema/context&quot; xsi:schemaLocation=”http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:component-scan base-package=”com.mail”/&gt; &lt;bean id=”mailSender” class=”org.springframework.mail.javamail.JavaMailSenderImpl”&gt; &lt;property name=”host” value=”smtp.163.com”/&gt;&lt;!–发送email的邮件服务器主机名–&gt; &lt;property name=”username” value=”test@163.com“/&gt;&lt;!–用户名–&gt; &lt;property name=”password” value=”test”/&gt;&lt;!–授权码–&gt; &lt;/bean&gt; &lt;bean id=”simpleMailMessage” class=”org.springframework.mail.SimpleMailMessage”&gt; &lt;property name=”subject” value=”hello mail”/&gt; &lt;property name=”from” value=”15657262398@163.com“/&gt; &lt;/bean&gt;&lt;/beans&gt; 装配和使用邮件发送器 package com.mail;import org.springframework.mail.MailSender;import org.springframework.mail.SimpleMailMessage;import org.springframework.stereotype.Service;import javax.annotation.Resource;@Servicepublic class OrderManagerImpl implements OrderManager { @Resource private MailSender mailSender; @Resource private SimpleMailMessage simpleMailMessage; @Override public void placeOrder() { SimpleMailMessage msg=new SimpleMailMessage(this.simpleMailMessage); msg.setTo(“test@163.com“); msg.setText(“hello”); this.mailSender.send(msg); }} &nbsp;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Spring-整合JDBC-事务-远程方法调用RMI]]></title>
    <url>%2Fdlh1234okok.github.io%2F2018%2F10%2F04%2FSpring-%E6%95%B4%E5%90%88JDBC-%E4%BA%8B%E5%8A%A1-%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8RMI%2F</url>
    <content type="text"><![CDATA[一、spring整合JDBC spring整合jdbc使用了模版方法设计模式 定义一套规范，固定流程不变，传入可变内容 1、Maven项目添加依赖 spring-context坐标依赖 mysql驱动包 c3p0连接池 spring jdbc 2、准备数据库的配置文件 3、xml配置 &lt;?xml version=”1.0” encoding=”UTF-8”?&gt;&lt;beans xmlns=”http://www.springframework.org/schema/beans&quot; xmlns:xsi=”http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=”http://www.springframework.org/schema/context&quot; xsi:schemaLocation=”http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!–配置扫描器–&gt; &lt;context:component-scan base-package=”com.shsxt”/&gt; &lt;!–加载properties–&gt; &lt;context:property-placeholder location=”classpath:jdbc.properties”/&gt; &lt;!–配置数据源c3p0–&gt; &lt;bean id=”dataSource” class=”com.mchange.v2.c3p0.ComboPooledDataSource”&gt; &lt;property name=”driverClass” value=”${jdbc.driver}”/&gt; &lt;property name=”jdbcUrl” value=”${jdbc.url}”/&gt; &lt;property name=”user” value=”${jdbc.user}”/&gt; &lt;property name=”password” value=”${jdbc.password}”/&gt; &lt;/bean&gt; &lt;!–配置JdbcTemplate–&gt; &lt;bean id=”jdbcTemplate” class=”org.springframework.jdbc.core.JdbcTemplate”&gt; &lt;property name=”dataSource” ref=”dataSource”/&gt; &lt;/bean&gt;&lt;/beans&gt; 这里使用了c3p0数据源 C3P0有自动回收空闲连接功能； dbcp没有自动回收空闲连接功能； 4、使用spring jdbc完成crud操作 package com.shsxt;import com.shsxt.po.Account;import com.sun.xml.internal.bind.v2.model.core.ID;import org.apache.commons.lang3.StringUtils;import org.springframework.jdbc.core.BatchPreparedStatementSetter;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.PreparedStatementCreator;import org.springframework.jdbc.core.RowMapper;import org.springframework.jdbc.support.GeneratedKeyHolder;import org.springframework.jdbc.support.KeyHolder;import org.springframework.stereotype.Component;import org.springframework.stereotype.Repository;import javax.annotation.Resource;import javax.lang.model.element.Name;import java.math.BigDecimal;import java.sql.;import java.util.ArrayList;import java.util.List;@Repositorypublic class AccountDaoImpl implements AccountDao {​ @Resource​ private JdbcTemplate jdbcTemplate; /** 添加记录返回受影响行数 @param account @return / @Override public Integer saveAccount(Account account) { String sql=”insert into account (name,type,money,remark,create_time,update_time,userId) values(?,?,?,?,?,?,?)”; return jdbcTemplate.update(sql,account.getName(),account.getType(),account.getMoney(),account.getRemark(),account.getCreate_time(),account.getUpdate_time(),account.getUserId()); } /** 添加记录返回主键 @param account @return / @Override public Integer saveAccountHasPrimaryKey(Account account) { String sql=”insert into account (name,type,money,remark,create_time,update_time,userId) values(?,?,?,?,?,?,?)”; KeyHolder keyHolder=new GeneratedKeyHolder(); jdbcTemplate.update(new PreparedStatementCreator() { @Override public PreparedStatement createPreparedStatement(Connection con) throws SQLException { PreparedStatement ps=con.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS); ps.setString(1,account.getName()); ps.setString(2,account.getType()); ps.setBigDecimal(3,account.getMoney()); ps.setString(4,account.getRemark()); ps.setObject(5,account.getCreate_time()); ps.setObject(6,account.getUpdate_time()); ps.setInt(7,account.getUserId()); return ps; } },keyHolder); return keyHolder.getKey().intValue(); } /** 批量添加记录 @param accounts @return / @Override public Integer saveAccountsBatch(List&lt;Account&gt; accounts) { String sql=”insert into account (name,type,money,remark,create_time,update_time,userId) values(?,?,?,?,?,?,?)”; return jdbcTemplate.batchUpdate(sql, new BatchPreparedStatementSetter() { @Override public void setValues(PreparedStatement ps, int i) throws SQLException { ps.setString(1,accounts.get(i).getName()); ps.setString(2,accounts.get(i).getType()); ps.setBigDecimal(3,accounts.get(i).getMoney()); ps.setString(4,accounts.get(i).getRemark()); ps.setObject(5,accounts.get(i).getCreate_time()); ps.setObject(6,accounts.get(i).getUpdate_time()); ps.setInt(7,accounts.get(i).getUserId()); } @Override public int getBatchSize() { return accounts.size(); } }).length; } /** 统计账户记录-聚合查询 @param userId @return / @Override public Integer countAccountsByUserId(Integer userId) { String sql=”select count(1) from account where userId=?”; return jdbcTemplate.queryForObject(sql,Integer.class,userId); } /** 根据id查询记录详情 @param Id @return / @Override public Account queryAccountById(Integer Id) { String sql=”select id,userId,name,type,money,remark,update_time,create_time from account where id=?”; return (Account) jdbcTemplate.queryForObject(sql,new Object[]{Id}, new RowMapper&lt;Account&gt;() { @Override public Account mapRow(ResultSet rs, int rowNum) throws SQLException { Account account=new Account(); account.setUpdate_time(rs.getDate(“update_time”)); account.setRemark(rs.getString(“remark”)); account.setType(rs.getString(“type”)); account.setMoney(rs.getBigDecimal(“money”)); account.setCreate_time(rs.getDate(“create_time”)); account.setId(rs.getInt(“id”)); account.setName(rs.getString(“name”)); account.setUserId(rs.getInt(“userId”)); return account; } }); } /** 多条件查询 @param userId @param type @param createTime @param aname @return / @Override public List&lt;Account&gt; queryAccountsByParams(Integer userId, String type, String createTime, String aname) { StringBuffer sql=new StringBuffer(“select id,userId,name,type,money,remark,update_time,create_time from account where 1=1”); List&lt;Object&gt; params=new ArrayList&lt;&gt;(); if (null!=userId){ sql.append(“ and userId=?”); params.add(userId); } if (StringUtils.isNotBlank(type)){ sql.append(“ and type=? “); params.add(type); } if (StringUtils.isNotBlank(createTime)){ sql.append(“ and createTime=?”); params.add(createTime); } if (StringUtils.isNotBlank(aname)){ sql.append(“ and name=?”); params.add(aname); } return jdbcTemplate.query(sql.toString(), params.toArray(), new RowMapper&lt;Account&gt;() { @Override public Account mapRow(ResultSet rs, int rowNum) throws SQLException { Account account=new Account(); account.setId(rs.getInt(“id”)); account.setUserId(rs.getInt(“userId”)); account.setName(rs.getString(“name”)); account.setCreate_time(rs.getDate(“create_time”)); account.setMoney(rs.getBigDecimal(“money”)); account.setType(rs.getString(“type”)); account.setRemark(rs.getString(“remark”)); account.setUpdate_time(rs.getDate(“update_time”)); return account; } }); } @Override public Integer updateAccount(Account account) { String sql=”update account set name=?,type=?,money=? where id=?”; return jdbcTemplate.update(sql,account.getName(),account.getType(),account.getMoney(),account.getId()); } / 批量更新 @param accounts @return / @Override public Integer updateAccountsBatch(List&lt;Account&gt; accounts) { String sql=”update account set name=?,type=?,money=? where id=?”; return jdbcTemplate.batchUpdate(sql, new BatchPreparedStatementSetter() { @Override public void setValues(PreparedStatement ps, int i) throws SQLException { ps.setString(1,accounts.get(i).getName()); ps.setString(2,accounts.get(i).getType()); ps.setBigDecimal(3,accounts.get(i).getMoney()); ps.setInt(4,accounts.get(i).getId()); } @Override public int getBatchSize() { return accounts.size(); } }).length; } / 根据id删除记录 @param id @return / @Override public Integer deleteAccountById(Integer id) { String sql=”delete from account where id=?”; return jdbcTemplate.update(sql,id); } /* 批量删除 @param ids @return */ @Override public Integer deleteAccountsBatch(Integer[] ids) { String sql=”delete from account where id=?”; return jdbcTemplate.batchUpdate(sql, new BatchPreparedStatementSetter() { @Override public void setValues(PreparedStatement ps, int i) throws SQLException { ps.setInt(1,ids[i]); } @Override public int getBatchSize() { return ids.length; } }).length; } @Override public Integer inMoney(Integer sourceId, BigDecimal money) { String sql=”update account set money=money-? where id=?”; return jdbcTemplate.update(sql,money,sourceId); } @Override public Integer outMoney(Integer targetId, BigDecimal money) { String sql=”update account set money=money+? where id=?”; return jdbcTemplate.update(sql,money,targetId); }}crud &nbsp; 二、spring事务 1、事务的四大特性（ACID） 原子性(Atomicity)：共生死，要么全部成功，要么全部失败 一致性(Consistency)：事务在执行前后，数据库中数据要保持一致性状态 隔离性(Lsolation)：事务与事务之间的执行应当是相互隔离互不影响的 持久性(Durability)：事务提交完毕后，数据库中的数据的改变是永久的 &nbsp; 2、事务配置 1)、添加坐标依赖 aop、spring事务 2)、XML配置 修改xml命名空间 xmlns:tx=”http://www.springframework.org/schema/tx&quot; http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd &lt;!–aop代理–&gt; &lt;aop:aspectj-autoproxy/&gt; &lt;!–事务配置–&gt; &lt;bean id=”txManager” class=”org.springframework.jdbc.datasource.DataSourceTransactionManager”&gt; &lt;property name=”dataSource” ref=”dataSource”/&gt; &lt;/bean&gt; &lt;!–事务通知配置–&gt; &lt;tx:advice id=”txAdvice” transaction-manager=”txManager”&gt; &lt;tx:attributes&gt; &lt;!–配置事务要拦截的方法–&gt; &lt;tx:method name=”save“ propagation=”REQUIRED”/&gt; &lt;tx:method name=”update“ propagation=”REQUIRED”/&gt; &lt;tx:method name=”del“ propagation=”REQUIRED”/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!–aop切面定义–&gt;​ &lt;aop:config&gt;​ &lt;aop:pointcut id=”cut” expression=”execution( com.shsxt.service...(..))”&gt;&lt;/aop:pointcut&gt;​ &lt;aop:advisor advice-ref=”txAdvice” pointcut-ref=”cut”/&gt;​ &lt;/aop:config&gt; &lt;!–注解方式配置事务，可以和xml配置共同使用–&gt; &lt;tx:annotation-driven transaction-manager=”txManager”/&gt; &nbsp; 3)、注解使用事务，xml配置后在方法上添加注解 4)、事务传播行为 &nbsp; 三、远程方法调用RMI Java RMI 指的是远程方法调用 (Remote Method Invocation)。它是一种机制，能够让在某个 Java 虚拟机上的对象调用另一个 Java 虚拟机中的对象上的方法。 JVM 可以位于相同或不同计算机上，在多个 JVM 中，一个 JVM 可以调用存储在其它 JVM 的对象的方法。 具体实现先不写了，我还没弄清楚。待修改]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux基本命令和项目发布]]></title>
    <url>%2Fdlh1234okok.github.io%2F2018%2F10%2F04%2FLinux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E5%92%8C%E9%A1%B9%E7%9B%AE%E5%8F%91%E5%B8%83%2F</url>
    <content type="text"><![CDATA[一、基本命令 date：查看当前日期 pwd：查看当前位置 cd：目录切换 ls|ll：查看当前目录文件与文件夹 mkdir+目录名：创建文件夹（可创建多个） rm -rf +目录：删除文件夹（可删除多个） mv 原始目录&nbsp; 修改后目录&nbsp; 文件移动/重命名 vim 文件名：创建或打开文件 i，编辑状态；esc退出编辑状态 &nbsp; &nbsp;：wq&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;写入并退出，：q&nbsp; &nbsp; 退出 cp 源文件地址&nbsp; 目标文件目录：文件copy cp -r 源文件夹目录&nbsp; 目标文件夹目录：文件夹copy &nbsp; 二、项目发布到Linux配置 1、静态ip配置步骤 1.选择桥接模式 2.启动后修改网卡文件 vi&nbsp; /etc/sysconfig/network-scripts/ifcfg-eth0&nbsp; 修改ip地址 执行测试 ping 192.168.1.1 ping 192.168.1.188 ping ***.com &nbsp; 2、连接终端(我使用了xshell) &nbsp; 3、安装jdk yum list|grep jdk&nbsp; &nbsp;查找jdk相关软件 yum install jdk.xxx&nbsp; &nbsp; 安装指定版本jdk 4、安装tomcat wget+tomcat下载地址 ./startup.sh&nbsp; &nbsp;在bin目录下执行启动脚本 关闭tomcat： ./shutdown.sh&nbsp; 执行脚本关闭 ps -ef|grep tomcat 查找tomcat相关进程 kill -9&nbsp; 进程号&nbsp; 关闭相关进程 5、防火墙设置 service iptables status&nbsp; &nbsp;查看防火墙状态 service iptables stop&nbsp; &nbsp;关闭防火墙 &nbsp; 测试..外部输入ip访问tomcat主页 &nbsp; 6、mysql安装和配置 查看mysql安装历史 rpm -qa | grep mysql 卸载mysql yum -y remove mysql 安装mysql yum -y install mysql-server mysql mysql-devel &nbsp; 启动服务 service mysqld start 启动 service mysqld stop 停止 service mysqld restart 重启 &nbsp; 创建管理员 mysqladmin&nbsp; -u&nbsp; root&nbsp; &nbsp;password&nbsp; *** 执行登录 mysql&nbsp; -uroot&nbsp; &nbsp;-p*** 授权 grant all privileges on . to ‘用户名‘@’%’ identified by ‘密码串’ with grant option; FLUSH&nbsp; &nbsp;PRIVILEGES; &nbsp; &nbsp; 使用sqlyog | navicat 进行连接 &nbsp; 7、将打包好的war包放到tomcat/webapp目录下，启动tomcat（项目名为站点名） &nbsp; 三、idea Maven项目打包 本地环境&nbsp; dev 测试环境&nbsp; test 生产环境&nbsp; product &nbsp; 配置打包标签 &lt;profiles&gt; &lt;profile&gt; &lt;id&gt;dev&lt;/id&gt; &lt;properties&gt; &lt;env&gt;dev&lt;/env&gt; &lt;/properties&gt; &lt;activation&gt; &lt;!– 默认运行开发环境 –&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;test&lt;/id&gt; &lt;properties&gt; &lt;env&gt;test&lt;/env&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;product&lt;/id&gt; &lt;properties&gt; &lt;env&gt;product&lt;/env&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;/profiles&gt; 指定资源文件 &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources/${env}&lt;/directory&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;/*.xml&lt;/include&gt; &lt;include&gt;/.properties&lt;/include&gt; &lt;include&gt;**/.tld&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; 打包命令配置 clean&nbsp; compile package -Dmaven.test.skip=true -Ptest|dev|product 清理编译文件，打包跳过测试文件 test/dev/product 包]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用poi读取Excel和写出Excel]]></title>
    <url>%2Fdlh1234okok.github.io%2F2018%2F10%2F04%2F%E4%BD%BF%E7%94%A8poi%E8%AF%BB%E5%8F%96Excel%E5%92%8C%E5%86%99%E5%87%BAExcel%2F</url>
    <content type="text"><![CDATA[本次使用到的jar包 1234567891011121314151617181920&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;3.9&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;3.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.38&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.4&lt;/version&gt; &lt;/dependency&gt; &nbsp; 1、从数据库读取数据写出到Excel 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package com.shsxt;import com.shsxt.po.Account;import org.apache.poi.hssf.usermodel.*;import javax.swing.filechooser.FileSystemView;import java.io.*;import java.util.List;/** * 简单的查询数据库将结果存到Excel */public class CreateExcel01 &#123; // 数据库查询 public static List&lt;Account&gt; query() &#123; String sql = "select * from tb_account"; List&lt;Account&gt; list = BaseDao.findRows(sql, null, Account.class); return list; &#125; // 创建Excel public static void createExcel()&#123; try &#123; // 获取桌面路径 FileSystemView fsv = FileSystemView.getFileSystemView(); String desktop = fsv.getHomeDirectory().getPath(); String filePath = desktop + "/template.xls"; File file = new File(filePath); OutputStream outputStream = new FileOutputStream(file); HSSFWorkbook workbook = new HSSFWorkbook(); // 创建一个工作表 HSSFSheet sheet = workbook.createSheet("Sheet1"); // 创建首行/头（第0行开始） HSSFRow head = sheet.createRow(0); String[] header = new String[]&#123;"账户id","账户名称","账户类型","账户金额","账户备注","创建时间","用户id","修改时间"&#125;; for (int i=0;i&lt;header.length;i++)&#123; // 设置首行信息 head.createCell(i).setCellValue(header[i]); &#125; head.setHeightInPoints(20); // 设置行的高度 // 从数据查询返回的集合 List&lt;Account&gt; accounts=query(); // 日期格式化 HSSFCellStyle cellStyle2 = workbook.createCellStyle(); HSSFCreationHelper creationHelper = workbook.getCreationHelper(); // 设置日期格式 cellStyle2.setDataFormat(creationHelper.createDataFormat().getFormat("yyyy-MM-dd")); sheet.setColumnWidth(3, 15 * 256); sheet.setColumnWidth(5, 20 * 256); sheet.setColumnWidth(7, 20 * 256);// 设置列的宽度 // 保留两位小数 HSSFCellStyle cellStyle3 = workbook.createCellStyle(); cellStyle3.setDataFormat(HSSFDataFormat.getBuiltinFormat("0.00")); for(int i=0;i&lt;accounts.size();i++) &#123; // 创建行（从第一行开始） HSSFRow row1 = sheet.createRow(i + 1); // id row1.createCell(0).setCellValue(accounts.get(i).getId()); // 账户名称 row1.createCell(1).setCellValue(accounts.get(i).getAccountName()); // 账户类型 row1.createCell(2).setCellValue(accounts.get(i).getAccountType()); // 账户金额（添加样式，保留两位小数） HSSFCell money = row1.createCell(3); money.setCellStyle(cellStyle3); money.setCellValue(accounts.get(i).getMoney()); // 账户备注 row1.createCell(4).setCellValue(accounts.get(i).getRemark()); // 创建时间（格式化时间） HSSFCell date1 = row1.createCell(5); date1.setCellStyle(cellStyle2); date1.setCellValue(accounts.get(i).getCreateTime()); // 用户id row1.createCell(6).setCellValue(accounts.get(i).getUid()); // 更新时间 HSSFCell date2 = row1.createCell(7); date2.setCellStyle(cellStyle2); date2.setCellValue(accounts.get(i).getUpdateTime()); &#125; workbook.setActiveSheet(0); workbook.write(outputStream); outputStream.close(); &#125; catch (IOException e1) &#123; e1.printStackTrace(); &#125; &#125;&#125;class test&#123; public static void main(String[] args)&#123; CreateExcel01.createExcel(); &#125;&#125; 2、从Excel读取写入到数据库 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127package com.shsxt;import org.apache.commons.lang3.time.DateFormatUtils;import org.apache.poi.hssf.usermodel.HSSFCell;import org.apache.poi.hssf.usermodel.HSSFDataFormat;import org.apache.poi.hssf.usermodel.HSSFDateUtil;import org.apache.poi.hssf.usermodel.HSSFWorkbook;import org.apache.poi.ss.formula.functions.Rows;import org.apache.poi.ss.usermodel.*;import org.apache.poi.xssf.usermodel.XSSFWorkbook;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Date;import java.util.Iterator;import java.util.List;public class ReadExcelToDB &#123; public List&lt;List&lt;Object&gt;&gt; importExcel(File file) &#123; List&lt;List&lt;Object&gt;&gt; dataList = null; try &#123; dataList = new ArrayList&lt;List&lt;Object&gt;&gt;(); // Excel对象 Workbook workbook = null; // 获取文件名 String fileName = file.getName().toLowerCase(); // 判断后缀 if (fileName.endsWith("xls")) &#123; workbook = new HSSFWorkbook(new FileInputStream(file)); &#125; else if (fileName.endsWith("xlsx")) &#123; workbook = new XSSFWorkbook(new FileInputStream(file)); &#125; else &#123; throw new RuntimeException("该文件不是Excel文件"); &#125; // 获取Excel中的第一个表格 Sheet sheet = workbook.getSheet("Sheet1"); // 得到表格中的数据的行数，最后一行 int rows = sheet.getLastRowNum(); if (rows == 0) &#123; throw new RuntimeException("表格中没有数据"); &#125; Row row = null; //行对象 Iterator&lt;Cell&gt; cols = null; // 列对象的迭代器 List&lt;Object&gt; list = null; for (int i = 1; i &lt;= rows; i++) &#123; row = sheet.getRow(i); // 获取第i行 if (row != null) &#123; cols = row.cellIterator(); // 获取该行的迭代器 list = new ArrayList&lt;Object&gt;(); while (cols.hasNext()) &#123; // 循环获取每一列数据存到list中 list.add(getCellObj(cols.next())); &#125; // 将这行数据存到集合dataList中 dataList.add(list); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return dataList; &#125; private Object getCellObj(Cell cell) &#123; if (cell == null) &#123; return ""; &#125; Object cellObj; switch (cell.getCellType()) &#123; case HSSFCell.CELL_TYPE_STRING: //字符串 cellObj = cell.getStringCellValue(); break; case HSSFCell.CELL_TYPE_NUMERIC: //数字 // poi把日期类型也归为数字类型 if (HSSFDateUtil.isCellDateFormatted(cell))&#123; // 获取日期对象并格式化 Date date=cell.getDateCellValue(); cellObj= DateFormatUtils.format(date,"yyyy-MM-dd"); &#125; else&#123; /*CellStyle cellStyle=cell.getCellStyle(); cellStyle.setDataFormat(HSSFDataFormat.getBuiltinFormat("0"));*/ cellObj = cell.getNumericCellValue(); &#125; break; case HSSFCell.CELL_TYPE_BOOLEAN: //boolean cellObj = cell.getBooleanCellValue(); break; case HSSFCell.CELL_TYPE_FORMULA: //公式 cellObj = cell.getCellFormula(); break; case HSSFCell.CELL_TYPE_BLANK: //空 cellObj = ""; break; case HSSFCell.CELL_TYPE_ERROR: //错误 cellObj = ""; break; default: cellObj=""; break; &#125; return cellObj; &#125;&#125;class Test &#123; public static void main(String[] args) &#123; File file = new File("C:\\Users\\Administrator\\Desktop\\no1.xls"); ReadExcelToDB readExcelToDB = new ReadExcelToDB(); List&lt;List&lt;Object&gt;&gt; lists=readExcelToDB.importExcel(file); for (List&lt;Object&gt; ObjList:lists)&#123; for (Object object:ObjList)&#123; System.out.println(object); &#125; System.out.println("____________"); &#125; &#125;&#125; 读取的结果是： &nbsp; 调用数据库插入就可以往插入到数据库了]]></content>
      <categories>
        <category>poi</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo]]></title>
    <url>%2Fdlh1234okok.github.io%2F2018%2F10%2F03%2Fhello-hexo%2F</url>
    <content type="text"><![CDATA[​ 花了一天半时间终于把这个博客建好了，中间遇到了很多坑，网上搜了大量资源，略有不足，以后想到了再改改漂亮吧。 ​ 我转了几篇之前在博客园的博客到这里，都是一篇篇从html转为markdown转换来的，但是发现好多文章的图片无法正常显示，暂时也没有更好的办法，作罢，不过以后我都会在这里更新。 ​ 贴一下我看的各位博主写的教程链接，方便以后出现问题可以解决。 ​ 1、这是我看的第一篇，初次接触给我帮助很大 ​ https://blog.csdn.net/dgut_guangdian/article/details/79326107 ​ 2、这几篇修改了next主题样式，添加了些好玩的东西 ​ https://blog.csdn.net/zhy421202048/article/details/77877580 ​ https://blog.csdn.net/w_ngzeqi/article/details/73863543 ​ https://blog.csdn.net/csdnSR/article/details/78300820 ​ https://www.jianshu.com/p/3a05351a37dc ​ ​ 3、在添加gitment评论时对我有帮助的（但我好像至今无法使用…） ​ https://www.cnblogs.com/pangguoming/p/8094815.html ​ https://www.jianshu.com/p/57afa4844aaa]]></content>
  </entry>
</search>
