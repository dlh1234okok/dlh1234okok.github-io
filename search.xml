<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Mybatis学习(7)-mybatis代码自动化生成]]></title>
    <url>%2Fdlh1234okok.github.io%2F2018%2F10%2F10%2FMybatis%E5%AD%A6%E4%B9%A0-7%2F</url>
    <content type="text"><![CDATA[借助Maven插件实现mybatis基本crud代码生成 配置pom.xml123456789101112&lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;configuration&gt; &lt;configurationFile&gt;src/main/resources/generatorConfig.xml&lt;/configurationFile&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; 配置generatorConfig.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt; &lt;!--数据库驱动--&gt; &lt;!--数据库驱动jar包路径--&gt; &lt;classPathEntry location="G:\Java\repository\mysql\mysql-connector-java\5.1.39\mysql-connector-java-5.1.39.jar"/&gt; &lt;context id="DB2Tables" targetRuntime="MyBatis3"&gt; &lt;commentGenerator&gt; &lt;property name="suppressDate" value="true"/&gt; &lt;property name="suppressAllComments" value="true"/&gt; &lt;/commentGenerator&gt; &lt;!--数据库链接地址账号密码--&gt; &lt;jdbcConnection driverClass="com.mysql.jdbc.Driver" connectionURL="jdbc:mysql://127.0.0.1:3306/mybatis" userId="root" password="123456"&gt; &lt;/jdbcConnection&gt; &lt;javaTypeResolver&gt; &lt;property name="forceBigDecimals" value="false"/&gt; &lt;/javaTypeResolver&gt; &lt;!--生成 Model 类存放位置--&gt; &lt;javaModelGenerator targetPackage="com.shsxt.po" targetProject="G:\idea\Workspaces\spring_mybatis\src\main\java" &gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;property name="trimStrings" value="true"/&gt; &lt;/javaModelGenerator&gt; &lt;!--生成映射文件存放位置--&gt; &lt;sqlMapGenerator targetPackage="com.shsxt.mapper" targetProject="G:\idea\Workspaces\spring_mybatis\src\main\java" &gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;/sqlMapGenerator&gt; &lt;!--生成 Dao 类存放位置--&gt; &lt;javaClientGenerator type="XMLMAPPER" targetPackage="com.shsxt.dao" targetProject="G:\idea\Workspaces\spring_mybatis\src\main\java" &gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;/javaClientGenerator&gt; &lt;!--tableName：数据库中的表名 domainObjectName:要生成的实体类类名--&gt; &lt;table tableName="account" domainObjectName="Account" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"&gt;&lt;/table&gt; &lt;table tableName="card" domainObjectName="Card" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"&gt;&lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 执行配置 执行成功后，会自动生成对应的实体类，mybatis映射文件，映射接口类]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mybatis学习(6)-分页插件]]></title>
    <url>%2Fdlh1234okok.github.io%2F2018%2F10%2F10%2FMybatis%E5%AD%A6%E4%B9%A0-6%2F</url>
    <content type="text"><![CDATA[添加依赖12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;4.1.0&lt;/version&gt; &lt;/dependency&gt; 修改mybatis配置文件12345678910111213141516171819202122232425262728293031&lt;plugins&gt; &lt;!-- com.github.pagehelper 为 PageHelper 类所在包名 --&gt; &lt;plugin interceptor="com.github.pagehelper.PageHelper"&gt; &lt;property name="dialect" value="mysql"/&gt; &lt;!-- 该参数默认为 false --&gt; &lt;!-- 设置为 true 时，会将 RowBounds 第一个参数 offset 当成 pageNum 页码使 用 --&gt; &lt;!-- 和 startPage 中的 pageNum 效果一样 --&gt; &lt;property name="offsetAsPageNum" value="true"/&gt; &lt;!-- 该参数默认为 false --&gt; &lt;!-- 设置为 true 时，使用 RowBounds 分页会进行 count 查询 --&gt; &lt;property name="rowBoundsWithCount" value="true"/&gt; &lt;!-- 设置为 true 时，如果 pageSize=0 或者 RowBounds.limit = 0 就会查询出 全部的结果 --&gt; &lt;!-- （相当于没有执行分页查询，但是返回结果仍然是 Page 类型） --&gt; &lt;property name="pageSizeZero" value="true"/&gt; &lt;!-- 3.3.0 版本可用 - 分页参数合理化，默认 false 禁用 --&gt; &lt;!-- 启用合理化时，如果 pageNum&lt;1 会查询第一页，如果 pageNum&gt;pages 会 查询最后一页 --&gt; &lt;!-- 禁用合理化时，如果 pageNum&lt;1 或 pageNum&gt;pages 会返回空数据 --&gt; &lt;property name="reasonable" value="true"/&gt; &lt;!-- 3.5.0 版本可用 - 为了支持 startPage(Object params)方法 --&gt; &lt;!-- 增加了一个`params`参数来配置参数映射，用于从 Map 或 ServletRequest 中取值 --&gt; &lt;!-- 可以配置 pageNum,pageSize,count,pageSizeZero,reasonable,不配置映 射的用默认值 --&gt; &lt;property name="params" value="pageNum=start;pageSize=limit;pageSizeZero=zero;reasonable=heli;count=countsql"/&gt; &lt;/plugin&gt; &lt;/plugins&gt; 添加对应接口查询分页方法12345678910111213/** * @param pageNum 页号 * @param pageSize 每页显示的数量 * @param userName 参数 * @return */ public PageInfo&lt;User&gt; queryUsersByParams(Integer pageNum,Integer pageSize,String userName)&#123; // 设置分页页号和每页显示数量 PageHelper.startPage(pageNum,pageSize); List&lt;User&gt; users = userDao.queryUsersByParams(userName); PageInfo&lt;User&gt; pageInfo = new PageInfo&lt;&gt;(users); return pageInfo; &#125; 单元测试1234567@Test public void test02()&#123; PageInfo&lt;User&gt; pageInfo = userService.queryUsersByParams(1,3,null); System.out.println(pageInfo.getPages()+"=="+pageInfo.getTotal()); List&lt;User&gt; users = pageInfo.getList(); for(User user:users) System.out.println(user); &#125;]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mybatis学习(5)-整合spring]]></title>
    <url>%2Fdlh1234okok.github.io%2F2018%2F10%2F10%2FMybatis%E5%AD%A6%E4%B9%A0-5%2F</url>
    <content type="text"><![CDATA[添加依赖1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!-- spring 核心 jar --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring 测试 jar --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.3.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring jdbc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;4.3.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring 事物 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;4.3.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- aspectj 切面编程的 jar --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.9&lt;/version&gt; &lt;/dependency&gt; &lt;!-- c3p0 连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加 mybatis 与 Spring 整合的核心包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql 驱动包 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.39&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志打印相关的 jar --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.2&lt;/version&gt; &lt;/dependency&gt; 添加配置文件log4j123456# Global logging configurationlog4j.rootLogger=DEBUG, stdout# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n db12345jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf8jdbc.username=rootjdbc.password=123456 mybatis123456789&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- po 包扫描 --&gt; &lt;typeAliases&gt; &lt;package name="com.shsxt.po"/&gt; &lt;/typeAliases&gt;&lt;/configuration&gt; spring12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context.xsdhttp://www.springframework.org/schema/aophttp://www.springframework.org/schema/aop/spring-aop.xsdhttp://www.springframework.org/schema/txhttp://www.springframework.org/schema/tx/spring-tx-3.0.xsd"&gt; &lt;!-- 扫描 com.shsxt 及其所有子包下类 --&gt; &lt;context:component-scan base-package="com.shsxt" /&gt; &lt;!-- 加载 properties 配置文件 --&gt; &lt;context:property-placeholder location="classpath:db.properties" /&gt; &lt;aop:aspectj-autoproxy /&gt;&lt;!-- aop --&gt; &lt;!-- 配置数据源 --&gt; &lt;!-- 配置 c3p0 数据源 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="$&#123;jdbc.driver&#125;"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.url&#125;"&gt;&lt;/property&gt; &lt;property name="user" value="$&#123;jdbc.username&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 设置事物增强 --&gt; &lt;tx:advice id="txAdvice" transaction-manager="txManager"&gt; &lt;tx:attributes&gt; &lt;tx:method name="get*" read-only="true" /&gt; &lt;tx:method name="find*" read-only="true" /&gt; &lt;tx:method name="query*" read-only="true" /&gt; &lt;tx:method name="load*" read-only="true" /&gt; &lt;tx:method name="add*" propagation="REQUIRED" /&gt; &lt;tx:method name="insert*" propagation="REQUIRED" /&gt; &lt;tx:method name="update*" propagation="REQUIRED"/&gt; &lt;tx:method name="delete*" propagation="REQUIRED" /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- aop 切面配置 --&gt; &lt;aop:config&gt; &lt;aop:pointcut id="servicePointcut" expression="execution(*com.shsxt.service..*.*(..))" /&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="servicePointcut"/&gt; &lt;/aop:config&gt; &lt;!-- 配置 sqlSessionFactory--&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;property name="configLocation" value="classpath:mybatis.xml" /&gt; &lt;!-- 自动扫描 com/shsxt/crm/mapper 目录下的所有 SQL 映射的 xml 文 件, 省掉 mybatis.xml 里的手工配置 value="classpath:com/shsxt/crm/mapper/*.xml"指的是 classpath(类路径) 下 com.shsxt.crm.mapper 包中的所有 xml 文件 UserMapper.xml 位于 com.shsxt.mapper 包下，这样 UserMapper.xml 就可 以被自动扫描 --&gt; &lt;property name="mapperLocations" value="classpath:com/shsxt/mapper/*.xml" /&gt; &lt;/bean&gt; &lt;!-- 配置扫描器 --&gt; &lt;bean id="mapperScanner" class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;!-- 扫描 com.shsxt.dao 这个包以及它的子包下的所有映射接口类 --&gt; &lt;property name="basePackage" value="com.shsxt.dao" /&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory" /&gt; &lt;/bean&gt;&lt;/beans&gt; mybatis映射sql文件1234567&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.shsxt.dao.UserMapper"&gt;&lt;/mapper&gt; 目录结构 单元测试12345678910@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = "classpath:spring.xml")public class Test01 &#123; @Resource private UserService userService; @Test public void test01()&#123; System.out.println(userService.queryUserById(6)); &#125;&#125;]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mybatis学习(4)-缓存]]></title>
    <url>%2Fdlh1234okok.github.io%2F2018%2F10%2F10%2FMybatis%E5%AD%A6%E4%B9%A0-4%2F</url>
    <content type="text"><![CDATA[简介​ 缓存在数据库查询中就是将查询出来的数据存到内存或者磁盘中，以便下次再进行同样查询操作的时候可以直接读取。相比于到数据库中重新查询，从内存或磁盘中读取数据更加快速。 ​ 正如大多数持久层框架一样，mybatis同样提供了一级缓存和二级缓存 ​ 1、一级缓存：基于PerpetualCache的HashMap本地缓存，其存储作用域为Session，当Session flush或close之后，该Session中的所有Cache就将清空。 ​ 2、二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache 的 HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache； ​ 对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了 C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。 ​ 如果二级缓存开启，首先从二级缓存查询数据，如果二级缓存有则从二级缓存中获取数据，如果没有则到一级缓存中查询，如果有就从一级缓存中获取，如果一级缓存中没有，再查询数据库。 一级缓存​ mybatis默认开启一级缓存，当连续进行一个sql查询的时候，第二次查询就是从缓存中读取。 1234567@Test public void test05()&#123; Integer total1 = userMapper.queryUserCount(); System.out.println(total1); Integer total2 = userMapper.queryUserCount(); System.out.println(total2); &#125; 我们发现只执行了一条sql，当在两次查询中间刷新缓存后，结果是： 二级缓存mybatis提供了二级缓存，但需要手动开启。 ​ 1、在mybatis配置文件中全局开启二级缓存（位置在properties标签下面） ​ 2、在需要的Mapper.xml映射文件中加入二级缓存 至此已经开启了二级缓存，映射语句文件中所有的select语句将会被缓存 测试结果： ​ 发现也只执行了一遍sql查询，“Cache Hit Ratio”缓存命中率，说明第二次查询是从缓存中读取。 补充说明： ​ 1、映射语句文件中所有的insert、update、delete语句都会刷新缓存。 ​ 2、缓存会使用Least Recently Used（LRU，最近最少使用）算法来回收 ​ 3、缓存会根据指定时间间隔来刷新 ​ 4、缓存会存储1024个对象 使用场景：​ 1、 对查询频率高， 变化频率低的数据建议使用二级缓存。​ 2、 对于访问多的查询请求且用户对查询结果实时性要求不高， 此时可采用mybatis 二级缓存技术降低数据库访问量， 提高访问速度， 业务场景比如： 耗时较高的统计分析 sql、 电话账单查询 sql 等 Cache标签常用属性： 12345&lt;cache eviction="FIFO" &lt;!--回收策略为先进先出--&gt;flushInterval="60000" &lt;!--自动刷新时间60s--&gt;size="512" &lt;!--最多缓存512个引用对象--&gt;readOnly="true"/&gt; &lt;!--只读--&gt; 分布式缓存Ehcache1、引入依赖 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt; &lt;artifactId&gt;ehcache-core&lt;/artifactId&gt; &lt;version&gt;2.4.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt; &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt; &lt;version&gt;1.0.3&lt;/version&gt; &lt;/dependency&gt; 2、缓存接口配置 1&lt;cache type="org.mybatis.caches.ehcache.EhcacheCache"/&gt; 3、添加配置文件（可以不设置，默认） 12345678910111213141516171819202122232425262728293031323334&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;ehcache xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../bin/ehcache.xsd"&gt; &lt;!-- name：Cache 的唯一标识 maxElementsInMemory：内存中最大缓存对象数 maxElementsOnDisk：磁盘中最大缓存对象数，若是 0 表示无穷大 eternal：Element 是否永远不过期，如果为 true，则缓存的数据始终有效，如果为 false 那么还要根据 timeToIdleSeconds，timeToLiveSeconds 判断 overflowToDisk：配置此属性，当内存中 Element 数量达到 maxElementsInMemory 时， Ehcache 将会 Element 写到磁盘中 timeToIdleSeconds：设置 Element 在失效前的允许闲置时间。仅当 element 不是永久有效 时使用，可选属性，默认值是 0，也就是可闲置时间无穷大 timeToLiveSeconds：设置 Element 在失效前允许存活时间。最大时间介于创建时间和失效 时间之间。仅当 element 不是永久有效时使用，默认是 0.，也就是 element 存活时间无穷 大 di skPersistent：是否缓存虚拟机重启期数据 diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是 120 秒 diskSpoolBufferSizeMB：这个参数设置 DiskStore（磁盘缓存）的缓存区大小。默认是 30MB。每个 Cache 都应该有自己的一个缓冲区上海尚学智能科技有限公司 memoryStoreEvictionPolicy：当达到 maxElementsInMemory 限制时，Ehcache 将会根据 指定的策略去清理内存。默认策略是 LRU（最近最少使用）。你可以设置为 FIFO（先进先 出）或是 LFU（较少使用） --&gt; &lt;defaultCache overflowToDisk="true" eternal="false"/&gt; &lt;diskStore path="D:/cache" /&gt; &lt;!-- &lt;cache name="sxtcache" overflowToDisk="true" eternal="false" timeToIdleSeconds="300" timeToLiveSeconds="600" maxElementsInMemory="1000" maxElementsOnDisk="10" diskPersistent="true" diskExpiryThreadIntervalSeconds="300" diskSpoolBufferSizeMB="100" memoryStoreEvictionPolicy="LRU" /&gt; --&gt;&lt;/ehcache&gt;]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mybatis学习(3)-映射关系处理]]></title>
    <url>%2Fdlh1234okok.github.io%2F2018%2F10%2F10%2FMybatis%E5%AD%A6%E4%B9%A0-3%2F</url>
    <content type="text"><![CDATA[简介​ 数据库大类分为关系型数据库和非关系型数据库，关系型数据库有Mysql、Oracle、Sql Server等，非关系型数据库有MongoDB、Redis等。 ​ 关系型数据库中的映射关系主要有： ​ 一对一：比如一个人对应一个身份证号码 ​ 一对多（多对一）：父亲对孩子，一个父亲可以多个孩子，而一个孩子只会有一个父亲 ​ 多对多：一个学生可以选择多门课程，而一门课程可以给多个学生选择 ​ 处理映射关系如何处理这些关系映射？ ​ 一对一：在一个数据表中添加另一个表的主键作为外键 ​ 一对多：建立一个中间表 ​ 多对多：拆分成两个一对多 在mybatis环境中实现 ​ 因为我们实体类中的字段最好是固定不变的，所以当需要用到另外一张表的字段时新建一个类来对应，我们把它们放到DTO层，专门用来装这些组合的不完整的数据实体。 1、一对一 新建一个实体类 1234567891011121314151617181920212223public class UserCardDto &#123; private User user; private Card card; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; public Card getCard() &#123; return card; &#125; public void setCard(Card card) &#123; this.card = card; &#125; @Override public String toString() &#123; return "UserCardDto&#123;" + "user=" + user + ", card=" + card + '&#125;'; &#125;&#125; 在mapper.xml中编写sql 123456789101112131415161718192021222324&lt;!--一对一--&gt; &lt;resultMap id="user_card_map" type="userCardDto"&gt; &lt;!--property：实体类中成员变量名--&gt; &lt;!--变量类型（别名）--&gt; &lt;association property="user" javaType="user"&gt; &lt;id column="userId" property="userId"/&gt; &lt;result column="userName" property="userName"/&gt; &lt;result column="userPwd" property="userPwd"/&gt; &lt;result column="nickName" property="userNick"/&gt; &lt;result column="card_id" property="cardId"/&gt; &lt;/association&gt; &lt;association property="card" javaType="card"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="card_num" property="cardNum"/&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id="queryCardUserById" parameterType="int" resultMap="user_card_map"&gt; select u.userName,u.nickName,c.card_num from user u left join card c on u.card_id=c.id where u.userId=#&#123;userId&#125; &lt;/select&gt; 2、一对多 12345678910111213141516171819202122232425262728293031public class UserCardAccountDto implements Serializable &#123; private User user; private Card card; private List&lt;Account&gt; accounts; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; public Card getCard() &#123; return card; &#125; public void setCard(Card card) &#123; this.card = card; &#125; public List&lt;Account&gt; getAccounts() &#123; return accounts; &#125; public void setAccounts(List&lt;Account&gt; accounts) &#123; this.accounts = accounts; &#125; @Override public String toString() &#123; return "UserCardAccountDto&#123;" + "user=" + user + ", card=" + card + ", accounts=" + accounts + '&#125;'; &#125;&#125; 123456789101112131415161718192021222324&lt;resultMap id="user_card_acc_map" extends="user_card_map" type="userCardAccountDto"&gt; &lt;!--property:字段名--&gt;&lt;!--ofType:集合中元素的类型--&gt; &lt;collection property="accounts" ofType="account"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="aname" property="aname"/&gt; &lt;result column="type" property="type"/&gt; &lt;result column="money" property="money"/&gt; &lt;result column="userId" property="userId"/&gt; &lt;result column="create_time" property="create_time"/&gt; &lt;result column="update_time" property="update_time"/&gt; &lt;result column="remark" property="remark"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id="queryUserCardAccountById" parameterType="int" resultMap="user_card_acc_map"&gt; select u.userId,u.userName,u.userPwd,u.userNick,u.card_id, c.id,c.card_num, a.id,a.aname,a.type,a.money,a.remark,a.create_time,a.update_time from user u left join card c on u.card_id=c.id left join account a on u.userId=a.userId where u.userId=#&#123;userId&#125; &lt;/select&gt; 查询出来的结果天然去重]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mybatis学习(2)-CRUD操作..]]></title>
    <url>%2Fdlh1234okok.github.io%2F2018%2F10%2F09%2FMybatis%E5%AD%A6%E4%B9%A0-2%2F</url>
    <content type="text"><![CDATA[增删改查​ 需要进行增删改查操作时，需要在映射文件中配置不同的标签，有常用参数parameterType，resultType等。除了查询操作时需要配置返回结果类型（resultType）标签，其他三种操作都不需要添加。 ​ 参数类型（parameterType）有：基本数据类型,字符串,map,java bean,list等 ​ 返回结果类型（resultType）有：基本数据类型,字符串,map,java bean,list等 查询操作（select）123&lt;select id="queryMapById" parameterType="int" resultType="map"&gt; select * from user where userId=#&#123;userId&#125;&lt;/select&gt; 添加操作（insert）（1）添加不返回主键 1234&lt;!--添加不返回主键--&gt; &lt;insert id="addUser" parameterType="user"&gt; insert into user (userName, userPwd, userNick) values (#&#123;userName&#125;,#&#123;userPwd&#125;,#&#123;userNick&#125;) &lt;/insert&gt; （2）添加返回主键（这里使用的是mysql） 1234567&lt;!--添加返回主键1--&gt; &lt;insert id="addUserHasKey" parameterType="user"&gt; &lt;selectKey keyProperty="userId" order="AFTER" resultType="int"&gt; select LAST_INSERT_ID() as id &lt;/selectKey&gt; insert into user (userName, userPwd, userNick) values (#&#123;userName&#125;,#&#123;userPwd&#125;,#&#123;userNick&#125;) &lt;/insert&gt; 1234&lt;!--添加返回主键2 推荐--&gt; &lt;insert id="addUserHasKey2" parameterType="user" useGeneratedKeys="true" keyProperty="userId"&gt; insert into user (userName, userPwd, userNick) values (#&#123;userName&#125;,#&#123;userPwd&#125;,#&#123;userNick&#125;) &lt;/insert&gt; ​ useGeneratedKeys:使用自动生成key ​ keyProperty:数据库中主键的名字 ​ 注意：mapper接口返回的依然是受影响的行数，但是主键已经赋值到实体类对象的id中了 （3）批量添加 1234567&lt;!--批量添加--&gt; &lt;insert id="addUserBatch" parameterType="list"&gt; insert into user (userName, userPwd, userNick) values &lt;foreach collection="list" item="item" separator=","&gt; (#&#123;item.userName&#125;,#&#123;item.userPwd&#125;,#&#123;item.userNick&#125;) &lt;/foreach&gt; &lt;/insert&gt; 删除操作（delete）123456789101112&lt;!--删除--&gt; &lt;delete id="deleteUser" parameterType="int"&gt; delete from user where userId=#&#123;userId&#125; &lt;/delete&gt; &lt;!--批量删除--&gt; &lt;delete id="deleteUserBatch" parameterType="list"&gt; delete from user where userId in( &lt;foreach collection="list" item="item" separator=","&gt; #&#123;item&#125; &lt;/foreach&gt; ) &lt;/delete&gt; 更新操作（update）123456789101112&lt;!--更新--&gt; &lt;update id="updateUser" parameterType="user"&gt; update user set userPwd=#&#123;userPwd&#125; where userId=#&#123;userId&#125; &lt;/update&gt; &lt;!--批量更新--&gt; &lt;update id="updateUserBatch" parameterType="int"&gt; update user set userPwd="8888" where userId in ( &lt;foreach collection="array" item="item" separator=","&gt; #&#123;item&#125; &lt;/foreach&gt; ) &lt;/update&gt; 设置事务自动提交在增删改操作中，默认不会自动进行事务提交，需要进行设置才会自动提交 1、在创建session时设置 1SqlSession sqlSession = sessionFactory.openSession(true); 2、commit方法 12SqlSession sqlSession = sessionFactory.openSession();sqlSession.commit(); 使用sql片段​ 发现在编写sql时，有很多重复的语句或者语段，为了复用这些语句，可以编写sql语句段 1234&lt;!--sql片段--&gt; &lt;sql id="base"&gt; user (userName, userPwd, userNick) &lt;/sql&gt; 然后可以在需要使用这段语句的地方使用“include”引用，如： 1234&lt;!--添加返回主键2--&gt; &lt;insert id="addUserHasKey2" parameterType="user" useGeneratedKeys="true" keyProperty="userId"&gt; insert into &lt;include refid="base"/&gt; values (#&#123;userName&#125;,#&#123;userPwd&#125;,#&#123;userNick&#125;) &lt;/insert&gt; #{}和${}的区别12select * from user where name = #&#123;name&#125;; select * from user where name = '$&#123;name&#125;'; #{}在动态解析时，会解析成一个参数占位符?，所以解析之后的语句是： 1select * from user where name = ?; ${}在动态解析时，会将我们填充的参数当做字符串的形式填充到语句中，结果是： 1select * from user where name = "zhangsan"; #{}能够很大程度防止sql注入，而${}不能；${}方式一般用于插入一个不改变的字符串，比如order by ${type}，或是在传入表名时。一般我们尽量使用#{}的方式。 resultMap​ 当数据库中字段名和对应java bean中的变量名不同时，总是需要在sql语句中使用as取别名来将查询出来的字段名转换为和java bean中的相同。此时使用resultMap可以将数据库中查询出来的结果自动映射成java bean。 123456&lt;resultMap id="resMap" type="user"&gt; &lt;id column="userId" property="userId"/&gt; &lt;!--主键--&gt; &lt;result column="userName" property="userName"/&gt; &lt;result column="userPwd" property="userPwd"/&gt; &lt;result column="userNick" property="userNick"/&gt; &lt;/resultMap&gt; ​ type：java bean的别名 ​ column：数据库中的字段名 ​ property：java bean中的变量名 因为我在数据库中的字段名和java中的变量名取的是相同的，所以写的也一样，这里只做一个演示 将resultType替换resultMap，值和id对应 mapper接口代理​ 遵循mybatis开发规范，mybatis框架可以自动生成mapper接口对象 ​ 1、mapper.xml中namespace等于接口类全限定名 ​ 2、mapper.java接口中方法名必须与mapper.xml中statement id一致 ​ 3、接口中输入参数类型必须与parameterType参数类型一致 ​ 4、接口中方法的返回值类型必须与映射文件中对应返回值类型一致 ​ 非集成环境：接口名与映射文件名称一致，映射文件与接口处于同一个包中 此时可以通过getMapper()方法传入接口的class对象返回接口的对象，所以测试代码可以这么写： 12345678@Testpublic void test01() throws IOException &#123; InputStream is = Resources.getResourceAsStream("mybatis.xml"); SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(is); SqlSession sqlSession = sessionFactory.openSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); System.out.println(userMapper.queryMapById(1));&#125; 动态sqlmybatis的强大特性就是它的动态sql，动态sql顾名思义就是随着传入的参数动态产生不同的sql。 使用动态sql时需要在接口方法参数中设置@param指定参数才能将参数传入if等条件中： 1public List&lt;User&gt; queryUsersByName(@Param("userName") String userName); if条件判断123456&lt;select id="queryUsersByName" parameterType="string" resultType="user"&gt; select * from user where 1=1 &lt;if test="null!=userName and ''!=userName"&gt; and userName like concat('%',#&#123;userName&#125;,'%') &lt;/if&gt; &lt;/select&gt; ​ 当使用动态sql时，为了防止sql语句结构不当，所以加上where 1=1。在段代码中只有当if中的条件成立时，才会拼接上其中的代码。 choose when otherwise​ 这个类似于java中的switch-case-default 123456789101112&lt;select id="queryUserByNick" parameterType="string" resultType="user"&gt; select userId &lt;choose&gt; &lt;when test="null!=userNick and ''!=userNick"&gt; ,userName,userNick &lt;/when&gt; &lt;otherwise&gt; ,userPwd &lt;/otherwise&gt; &lt;/choose&gt; from user where 1=1 &lt;/select&gt; Ognl表达式​ 我们在进行if或者choose-when-outherwise进行判断的时候经常要写判断条件如 1&lt;if test="null!=userName and ''!=userName"&gt;&lt;/if&gt; ​ 此时我们可以用Ognl访问工具类来简化这里的编写，表达式格式为：@class@method(args)，上面这条判断使用之后的格式是： 1&lt;if test="@Ognl@isNotEmpty(userName)"&gt;&lt;/if&gt; trim where set标签​ 在我们使用动态sql的时候，sql中总有些连接词不能正常拼接，比如下面的代码： 12345678910&lt;select id="queryUserByNameOrNick" parameterType="user" resultType="user"&gt; select * from user where &lt;if test="@Ognl@isNotEmpty(userName)"&gt; userName like concat('%',#&#123;userName&#125;,'%') &lt;/if&gt; &lt;if test="@Ognl@isNotEmpty(userNick)"&gt; and userNick like concat('%',#&#123;userNick&#125;,'%') &lt;/if&gt; &lt;/select&gt; ​ 这段sql中当第一个if不满足而第二个if满足时，sql拼接where条件后面就会多一个and，此时查询就会报异常，为了避免这种问题，可以使用where标签将条件内容包含起来，这个标签相当于一个where，而且在里面的动态sql会自动去除多余的and。 使用where标签后： 1234567891011&lt;select id="queryUserByNameAndNick" parameterType="user" resultType="user"&gt; select * from user &lt;where&gt; &lt;if test="@Ognl@isNotEmpty(userName)"&gt; userName like concat('%',#&#123;userName&#125;,'%') &lt;/if&gt; &lt;if test="@Ognl@isNotEmpty(userNick)"&gt; and userNick like concat('%',#&#123;userNick&#125;,'%') &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; ​ ​ set标签和where类似，set标签是在做更新操作的时候（update tbName set id=? where xxx）使用，同时更新多个字段，总会出现多余的“，”，使用set标签即可去除它们。 ​ trim标签既有where标签的作用又有set标签的作用： 1234567891011&lt;select id="queryUserByNameAndNick" parameterType="user" resultType="user"&gt; select * from user &lt;trim prefix="where" prefixOverrides="and|or"&gt; &lt;if test="@Ognl@isNotEmpty(userName)"&gt; userName like concat('%',#&#123;userName&#125;,'%') &lt;/if&gt; &lt;if test="@Ognl@isNotEmpty(userNick)"&gt; and userNick like concat('%',#&#123;userNick&#125;,'%') &lt;/if&gt; &lt;/trim&gt; &lt;/select&gt; forEach标签类似于JSTL的c:foreach标签，对一个集合进行遍历，通常在in或者插入多条数据时使用，如： 1234567&lt;!--批量添加--&gt; &lt;insert id="addUserBatch" parameterType="list"&gt; insert into user (userName, userPwd, userNick) values &lt;foreach collection="list" item="item" separator=","&gt; (#&#123;item.userName&#125;,#&#123;item.userPwd&#125;,#&#123;item.userNick&#125;) &lt;/foreach&gt; &lt;/insert&gt; 注解形式动态sql不常用，需要新建一个类来写sql语句 1、在接口方法上加上注解，如： 12@SelectProvider(method = "queryUserCount",type = UserProvider.class)public Integer queryUserCount(); ​ type指定sql类的class，method指定sql方法名 2、编写sql 123456789public class UserProvider &#123; public String queryUserCount()&#123; String total= new SQL()&#123;&#123; SELECT("count(*)"); FROM("user"); &#125;&#125;.toString(); return total; &#125;&#125; 这里的方法的返回值和接口方法的返回值不对应]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mybatis学习(1)-搭建和简单查询]]></title>
    <url>%2Fdlh1234okok.github.io%2F2018%2F10%2F09%2FMybatis%E5%AD%A6%E4%B9%A0-1%2F</url>
    <content type="text"><![CDATA[简介​ mybatis框架是一个基于java的持久层框架。持久层就是将数据存到持久化设备上（如数据库、硬盘等），它对于jdbc和持久层的操作做了简化，将sql和代码分离。 ​ mybatis不是一个完全的orm（对象关系映射）框架，和hibernate（对象关系映射框架）相比，它还需要自己编写sql语句，但是在某些业务逻辑多变的场景下，它可以由自己编写sql语句就显得更加灵活。 环境搭建maven项目 导入依赖​ mybatis核心依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt; &lt;/dependency&gt; ​ mysql驱动 12345&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.38&lt;/version&gt; &lt;/dependency&gt; ​ log4j依赖（可以输出操作过程，更容易在出错时找到问题） 12345&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; 添加mybatis配置文件12345678910111213141516171819202122232425262728&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 注册属性文件 --&gt; &lt;properties resource="jdbc.properties"/&gt; &lt;typeAliases&gt; &lt;!--配置实体类别名：包扫描 默认别名是类名--&gt; &lt;package name="com.shsxt.po"/&gt; &lt;/typeAliases&gt; &lt;!-- 配置MyBatis运行环境 --&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;driver&#125;"/&gt; &lt;property name="url" value="$&#123;url&#125;"/&gt; &lt;property name="username" value="$&#123;user&#125;"/&gt; &lt;property name="password" value="$&#123;password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;!-- 在这里可以配置另一个环境 --&gt; &lt;/environments&gt; &lt;!-- 注册映射文件 --&gt; &lt;mappers&gt; &lt;package name="com.shsxt.mapper"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; ​ 在配置时可以配置多个运行环境，默认运行标签指定的默认环境（上面为development环境），在需要切换环境时，可以在创建session工厂时指定，如： 1sqlSessionFactory = new SqlSessionFactoryBuilder().build(is,"test"); 配置映射文件（sql代码所在）​ 配置映射文件的方式有三种： 12345678&lt;mappers&gt; &lt;!--包扫描--&gt; &lt;package name="com.shsxt.mapper"/&gt; &lt;!--配置xml--&gt; &lt;mapper resource="com.shsxt.mapper.UserMapper"/&gt; &lt;!--配置接口--&gt; &lt;mapper class="com.shsxt.mapper.UserMapper"/&gt; &lt;/mappers&gt; ​ 一个实体类对应一个映射文件，所以当业务复杂有多个实体类时，包扫描的配置方式较为方便，而配置xml和配置接口都需要配置多个mapper标签。 创建一个xml文件作为映射文件，在java目录（因为不在resources目录下不会自动读取配置文件，所以需要指定java目录下读取配置文件） 1234567891011121314&lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.tld&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; xml映射文件 123456789101112&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.shsxt.mapper.UserMapper"&gt; &lt;!--数字--&gt; &lt;select id="queryUserByName" parameterType="string" resultType="user"&gt; select * from user where userName like concat('%',#&#123;userName&#125;,'%') &lt;!--concat:拼接字符串--&gt; &lt;/select&gt;&lt;/mapper&gt; namespace：指明命名空间，等于接口的全限定名，后面调用crud操作的时候需要 parameterType：指明输入参数类型（int,string,map,java bean,list..） resultType：指明输出数据类型（基本数据类型,string,map,java bean,list） ​ 在这里输出类型如果为List的话，只需要指明list中泛型的类型 ​ ·当输出类型为javabean类型时，需要写类所在的完整路径com.xxx.xxx.xx；为了书写方便，也可以指定它的别名，如上面一般。指定别名有三种方式： 123456&lt;typeAliases&gt; &lt;!--配置实体类别名：包扫描 默认别名是类名--&gt; &lt;package name="com.shsxt.po"/&gt; &lt;!--typeAlias标签指定路径--&gt; &lt;typeAlias type="com.shsxt.po.User" alias="user"/&gt; &lt;/typeAliases&gt; ​ 还可以把typeAlias中的alias标签以注解的方式写在javabean类的上面 ​ 和原生jdbc不同的是，原生jdbc的占位符’?’，在这里用#{传入参数的名字} ​ 基本配置就基本完成了，接下来就是调用了，从这里可以看出，mybatis环境中需要配置输入参数类型，输出参数类型和sql语句就可以完成数据库操作。 ​ 那我们知道数据库中一部分字段的类型和java中是不同的，比如数据库中的varchar，在java中是String，它是用什么转换的呢—-&gt;typeHandler类型处理器，在预处理语句中设置一个参数或者获取一个参数时，类型处理器都会将获取到的值以合适的方式转换为java类型 ​ 调用，实现一个查询其中主要过程 （1）读取资源文件 （2）创建sqlsession工厂 （3）由sqlsession工厂打开/创建session （4）通过session操作数据库 （5）处理结果 （6）关闭sqlsession 我在这里将映射文件对应了一个接口，实现了这个接口并且做了一些封装 12345678910111213141516171819202122232425262728public class UserMapperImpl implements UserMapper &#123; private SqlSessionFactory sqlSessionFactory; private static SqlSession sqlSession; public UserMapperImpl() &#123; &#125; public UserMapperImpl(SqlSessionFactory sqlSessionFactory) &#123; this.sqlSessionFactory = sqlSessionFactory; sqlSession = sqlSessionFactory.openSession(); &#125; @Override public List&lt;User&gt; queryUserByName(String userName) &#123; List&lt;User&gt; users = null; try &#123; users = sqlSession.selectList("com.shsxt.mapper.UserMapper.queryUserByName", userName); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (sqlSession != null) &#123; sqlSession.close(); &#125; &#125; return users; &#125;&#125; 单元测试代码 1234567891011121314151617public class Test01 &#123; private SqlSessionFactory sqlSessionFactory; private static UserMapper userMapper; @Before public void before() throws IOException &#123; InputStream is = Resources.getResourceAsStream("mybatis.xml"); sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); &#125; @Test public void test01() &#123; userMapper = new UserMapperImpl(sqlSessionFactory); List&lt;User&gt; users = userMapper.queryUserByName("z"); for (User user : users) System.out.println(user); &#125;&#125; 结果 因为使用了log4j日志采集，可以看到我们编写的sql还有查询到的总数量]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Ajax轮询和长轮询]]></title>
    <url>%2Fdlh1234okok.github.io%2F2018%2F10%2F07%2FAjax%E8%BD%AE%E8%AF%A2%E5%92%8C%E9%95%BF%E8%BD%AE%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[​ 在需要实时信息更新的时候，可以使用轮询不断向服务器请求获取数据，但是频繁请求服务器，效率低而且十分耗费资源，一般推荐使用webSocket建立持久连接 ​ 因为以前没有听说过这个名词，现在了解后在这里做一个备份（这里只贴出代码） 12345678910111213// Ajax轮询 var get = &#123; url:"user", type:"post", dataType:"json", success:function (data) &#123; console.log("next"); &#125; &#125;; // Ajax定时访问服务端，不断建立连接获取数据 window.setInterval(function () &#123; $.ajax(get) &#125;,1000); 1234567891011121314// Ajax长轮询 var get = &#123; url:"user", type:"post", dataType:"json", success:function (data) &#123; $.ajax(get); // 在Ajax的回调函数这里再次发送ajax请求 &#125;, error:function () &#123; $.ajax(get); // 当请求时间过长，再次调用ajax长轮询 &#125; &#125;; $.ajax(get); 在一次请求完成返回之后立刻再次发送请求，当没有数据就会被挂在服务器，但只要有数据就会返回。]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[webSocket学习(1)]]></title>
    <url>%2Fdlh1234okok.github.io%2F2018%2F10%2F07%2FwebSocket%E5%AD%A6%E4%B9%A0-1%2F</url>
    <content type="text"><![CDATA[一、webSocket是什么 ​ webSocket是html5推出的一种新协议，和HTTP协议基本没有关系，但是为了兼容现有浏览器的握手规范，需要通过HTTP协议完成一部分握手，也可以说是HTTP协议的补充，两者之间有交集，但不是全部，可以用以下这张图理解HTTP和webSocket的关系 二、为什么需要webSocket ​ HTTP协议是无状态（协议对事务处理没有记忆能力），无连接（一次请求即断开连接），单向的应用层协议（只能由客户端请求服务器，服务器无法主动向客户端发送消息）。 ​ 在这种单向请求的特点在服务器状态持续发生变化时客户端想要获知就很麻烦，（可以使用Ajax的轮询或者长轮询实现），但是轮询效率低并且十分耗费资源（因为要持续不断的打开连接） ​ 在这种情况下，webSocket应运而生了，webSocket只需要建立一次连接就可以保持连接，进行持久通信，而且客户端和服务端都可以通过连接发送数据到另一方。 ​ 在需要实时通信的需求下使用webSocket最好不过了 对于webSocket的介绍就到这里，贴一篇关于webSocket原理的文章参考 https://www.cnblogs.com/fuqiang88/p/5956363.html 三、通过Java实现webSocket通信的简易聊天室 js代码（客户端） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;主页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="text" id="userMsg"/&gt;&lt;button onclick="send()"&gt;发送消息&lt;/button&gt;&lt;/br&gt;&lt;button onclick="closeWebSocket()"&gt;关闭连接&lt;/button&gt;&lt;button onclick="clearMsg()"&gt;清屏&lt;/button&gt;&lt;div id="msg"&gt;&lt;/div&gt;&lt;div id="per"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script type="text/javascript" src="statics/jquery-3.3.1.min.js"&gt;&lt;/script&gt;&lt;%String nick = request.getParameter("nick");%&gt;&lt;script type="text/javascript"&gt; // 页面加载完毕没有登录则跳转到登录页面 $(function () &#123; var nick = &lt;%=nick%&gt;; if (nick==null)&#123; window.location.href="login.jsp"; &#125; &#125;); var webSocket = null; // 判断浏览器是否支持webSocket if ("WebSocket" in window)&#123; webSocket = new WebSocket("ws://192.168.1.139:8080/chat"); &#125;else&#123; alert("浏览器不支持webSocket") &#125; // 连接发生错误的回调方法 webSocket.onerror = function () &#123; setMsg("发生错误") &#125;; // 建立连接后要做的事情 webSocket.onopen = function () &#123; addUser(); &#125;; // 服务器发送过来的消息 webSocket.onmessage = function (event) &#123; setMsg(event.data); &#125;; // 关闭连接 webSocket.onclose = function () &#123; subUser(); &#125;; // 当浏览器关闭时关闭连接，防止后台报错 window.onbeforeunload = function () &#123; closeWebSocket(); &#125;; // 将信息显示在页面 function setMsg(msg)&#123; $('#msg').append(msg+"&lt;/br&gt;"); &#125; function addUser() &#123; webSocket.send('&lt;%=nick%&gt;'+"加入聊天室"); &#125; function subUser() &#123; webSocket.send('&lt;%=nick%&gt;'+"离开聊天室"); &#125; // 关闭webSocket连接 function closeWebSocket() &#123; webSocket.close(); window.location.href="login.jsp"; &#125; // 发送消息 function send() &#123; var userMsg= $('#userMsg').val(); webSocket.send('&lt;%=nick%&gt;'+"说："+userMsg); $('#userMsg').val(""); &#125; function clearMsg() &#123; $('#msg').empty(); &#125;&lt;/script&gt;&lt;/html&gt; java代码（服务端） ​ 在编写代码之前需要引入javaee标准 123456&lt;dependency&gt; &lt;groupId&gt;javax&lt;/groupId&gt; &lt;artifactId&gt;javaee-api&lt;/artifactId&gt; &lt;version&gt;7.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.shsxt.websocket;import javax.websocket.*;import javax.websocket.server.ServerEndpoint;import java.io.IOException;import java.util.concurrent.CopyOnWriteArraySet;// 建立一个webSocket的端点，要和js代码中对应@ServerEndpoint("/chat")public class ChatServer &#123; // 与客户端之间连接的会话，通过session向和客户端发送消息 private Session session; // concurrent包线程安全的set，用来存放chatServer对象 private static CopyOnWriteArraySet&lt;ChatServer&gt; set = new CopyOnWriteArraySet&lt;&gt;(); // 用来计算当前在线人数 private Integer onlineNum = 0; /** * 建立连接后要做的事情 */ @OnOpen public void onOpen(Session session)&#123; this.session = session; set.add(this); //将当前登录对象放入集合 System.out.println("webSocket连接已经建立.."); addOnline(); &#125; /** * 从客户端收到的消息 */ @OnMessage public void onMessage(String msg,Session session)&#123; this.session = session; try &#123; for (ChatServer chats:set)&#123; chats.session.getBasicRemote().sendText(msg); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** * 断开连接 */ @OnClose public void onClose(Session session)&#123; set.remove(this); System.out.println("断开连接..."); subOnline(); &#125; /** * 发生异常调用 */ @OnError public void onError(Throwable e)&#123; System.out.println("发生异常..."); e.printStackTrace(); &#125; public synchronized void addOnline()&#123; onlineNum++; &#125; public synchronized void subOnline()&#123; onlineNum--; &#125; // 获取在线人数 public synchronized Integer getOnline()&#123; return onlineNum; &#125;&#125; 以上内容大部分源于网络]]></content>
      <categories>
        <category>webSocket</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JS原生Ajax]]></title>
    <url>%2Fdlh1234okok.github.io%2F2018%2F10%2F04%2FJS%E5%8E%9F%E7%94%9FAjax%2F</url>
    <content type="text"><![CDATA[一、XMLHTTPRequest Ajax技术核心是XMLHTTPRequest对象（简称XHR），是由微软首先引入的一个特性，其他浏览器提供商后来都提供了相同的实现。在XHR出现之前，Ajax式的通信必须借助一些手段来实现，大多数是使用隐藏的框架或内嵌框架。 Ajax，是Asynchronout JavaScript+XML的简写。这种技术能够向服务器请求额外的数据而无需卸载/刷新页面，会带来更好的用户体验。 1、支持原生XHR对象的浏览器创建XHR对象可以直接实例化XMLHTTPRequest。 2、在使用XHR对象时，先必须调用open()方法，它接收三个参数：要发送的请求类型（get/post）、请求的URL和表示是否异步(async)。open()方法并不会真正发送请求，而只是启动一个请求以备发送。 3、通过send()方法进行发送请求，send()方法接受一个参数，作为请求主体发送的数据。如果不需要必须填null。执行send()方法后请求就会发送到服务器上。 4、请求发送到服务端收到响应后，响应的数据会自动填充XHR对象的属性，一共有四个属性： &nbsp; 5、接受响应之后，第一步检查status属性，以确定响应已经成功返回，有如下的状态代码： 6、判断http状态值以确定响应是否成功返回 7、当使用异步调用的时候，检测readyState属性，每当readyState属性改变时，触发readyStatechange事件。这个属性共有五个值： &nbsp;&nbsp;二、GET与POST 1、GET请求 通过URL后的问号给服务器传递键值对数据，服务器接收到返回响应数据。特殊字符传参产生的问题可以使用encodeURIComponent()进行编码处理，中文字符的返回及传参，可以将页面保存和设置为utf-8即可，AJAX返回的数据为UTF-8。 2、POST请求 通过发送POST请求的数据，不会跟在URL后面，而是通过send()方法向服务器提交数据 &nbsp; 向服务器发送POST请求由于解析机制的原因，需要进行特别的处理。因为POST请求和Web表单提交是不同的的，需要使用XHR来模仿表单提交。 从性能上来讲POST请求比GET请求消耗更多一些，用相同数据比较，GET请求最多比POST请求快两倍&nbsp;三、封装Ajax&lt;script type=”text/javascript”&gt;var obj={ url:“user”, method:“post”, data:{name:“zs”,age:18}, async:true, success:function(result){ console.log(result); console.log(JSON.parse(result)) }, error:function(result){ console.log(result); }}ajax(obj)function ajax(obj){​ //得到XMLHTTPRequest对象​ var xhr=new XMLHttpRequest();​ //将参数格式化​ obj.data=params(obj.data);​ //判断请求方式​ if(obj.method.toUpperCase()==”GET”){​ obj.url+=(obj.url.indexOf(“?”)==-1)?”?”+obj.data:”&amp;”+obj.data;​ //open()方法：请求方式/请求路径/是否异步 xhr.open(obj.method,obj.url,obj.async);​ //发送请求​ xhr.send(null);​ }else{ // POST请求 xhr.open(obj.method,obj.url,obj.async);​ //模拟表单提交​ xhr.setRequestHeader(“Content-Type”,”application/x-www-form-urlencode”);​ //发送请求 xhr.send(obj.data);​ }​ //判断是否是异步请求​ if(obj.async){ //异步请求​ //判断响应是否完全响应​ xhr.onreadystatechange=function(){​ if(xhr.readyState==4){​ callback();​ }​ }​ }else{​ callback();​ } //回调函数 function callback(){ if(xhr.status==200){ //回调函数 obj.success(xhr.responseText);​ }else{​ obj.error(“请求失败！错误状态码”+xhr.status+”,错误原因”+xhr.statusText);​ }​ }}/ 将json格式的字符串转换成普通的参数拼接 / function params(data){ var arr=[]; if(data!=null &amp;&amp; data !=””){ ​ for(var d in data){ ​ console.log(d+” “+data[d]); ​ var name=encodeURIComponent(d); ​ var value=encodeURIComponent(data[d]); arr.push(name+”=”+value); } var param=arr.join(“&amp;”); return param; } return null; } &lt;/script&gt; &nbsp; &nbsp;同步： 提交请求–&gt;等待服务器处理–&gt;处理完毕返回这个期间客户端浏览器不能干的事，当前只能做一件事。 异步： 请求通过事件触发–&gt;服务器处理（这时浏览器仍然可以做其他事情）–&gt;处理完毕。可以同时做多件事情&nbsp;四、JQuery封装的AJax $.ajax(){} $.get(){} $.getJson(){} $.post(){}]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Spring-IoC]]></title>
    <url>%2Fdlh1234okok.github.io%2F2018%2F10%2F04%2FSpring-IoC%2F</url>
    <content type="text"><![CDATA[一、Spring框架概念 spring 是众多开源 java 项目中的一员，基于分层的 javaEE 应用一站式轻量级开源框架，主要核心是 Ioc(控制反转/依赖注入) 与 Aop(面向切面)两大技术，实现项目在开发过程中的轻松解耦， 提高项目的开发效率。 在项目中引入spring的好处： &middot;降低组件之间的耦合度，实现软件各层之间的解耦 &middot;可以使用容器提供的众多服务，如：事务管理服务、消息服务等 &middot;当使用容器管理事务时，开发人员就不需要手工控制事务，也不需要处理复杂的事务传播 &middot;容器提供单例模式支持，开发人员不再需要自己编写实现代码 &middot;容器提供了AOP技术，利用它很容易实现如权限拦截、运行期监控等功能 &nbsp; 二、Spring源码架构 1、核心容器:spring-beans 和 spring-core 模块是 Spring 框架的核心模块，包含控制反转（Inversion of Control, IoC）和依赖注入（Dependency Injection, DI） ,核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory， 工厂模式的实现。 BeanFactory 使用控制反转（IOC） 思想将应用程序的配置和依赖性规范与实际的应用程序代码分开。 2、Spring 上下文 Spring Context： Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。 Spring 上下文包括企业服务，例如 JNDI、 EJB、电子邮件、国际化、校验和调度功能。 3、Spring-Expression 模块是统一表达式语言（unified EL）的扩展模块，可以查询、管理运行中的对象，同时也方便的可以调用对象方法、操作数组、集合等。它的语法类似于传统 EL，但提供了额外的功能，最出色的要数函数调用和简单字符串的模板函数。 4、Spring-AOP： spring-aop 是 Spring 的另一个核心模块, 在 Spring中，他是以 JVM 的动态代理技术为基础，然后设计出了一系列的Aop 横切实现，比如前置通知、返回通知、异常通知等。 通过其配置管理特性， Spring AOP 模块直接将面向切面的编程功能集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理的任何对象支持 AOP。 …… &nbsp;三、Spring容器工厂的简单实现 import org.dom4j.Document;import org.dom4j.DocumentException;import org.dom4j.Element;import org.dom4j.XPath;import org.dom4j.io.SAXReader; import java.lang.reflect.Method;import java.net.URL;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map; public class Factory_01 implements Factory {​ // Map集合用来存放id和class​ Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();​ List&lt;Bean&gt; beans = new ArrayList&lt;&gt;(); &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt; 实例化工厂对象时就完成以下操作&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;public&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; Factory_01(String fileName) { &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt; xml解析&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;this&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;.pathXml(fileName); &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt; 实例化对象&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;this&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;.instanceBean(); &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt; 属性赋值&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;this&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;.setProperty(); } &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt; 属性赋值&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;private&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;void&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; setProperty() { &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;try&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; { &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt;(&lt;span style=&quot;color: #0000ff;&quot;&gt;null&lt;/span&gt;!=beans &amp;amp;&amp;amp; beans.size()&amp;gt;0&lt;span style=&quot;color: #000000;&quot;&gt;){ &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;for&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;(Bean bean:beans){ List&lt;/span&gt;&amp;lt;Property&amp;gt; properties=&lt;span style=&quot;color: #000000;&quot;&gt;bean.getProperties(); &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt;(&lt;span style=&quot;color: #0000ff;&quot;&gt;null&lt;/span&gt;!=properties &amp;amp;&amp;amp; properties.size()&amp;gt;0&lt;span style=&quot;color: #000000;&quot;&gt;){ &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;for&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;(Property property:properties){ &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt; 得到property的id和ref&lt;/span&gt; String id=&lt;span style=&quot;color: #000000;&quot;&gt;property.getId(); String ref&lt;/span&gt;=&lt;span style=&quot;color: #000000;&quot;&gt;property.getRef(); &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt; set方法中首字母大写&lt;/span&gt; id=id.toUpperCase().charAt(0)+id.substring(1&lt;span style=&quot;color: #000000;&quot;&gt;); &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt; 获取到当前class&lt;/span&gt; Class clz=&lt;span style=&quot;color: #000000;&quot;&gt;map.get(bean.getId()).getClass(); &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt; 找到set方法&lt;/span&gt; Method method=clz.getDeclaredMethod(&quot;set&quot;+&lt;span style=&quot;color: #000000;&quot;&gt;id,map.get(ref).getClass()); method.invoke(map.get(bean.getId()),map.get(ref)); } } } } } &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;catch&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; (Exception e) { e.printStackTrace(); } } &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt; 实例化&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;private&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;void&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; instanceBean() { &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt; (&lt;span style=&quot;color: #0000ff;&quot;&gt;null&lt;/span&gt; != beans &amp;amp;&amp;amp; beans.size() &amp;gt; 0&lt;span style=&quot;color: #000000;&quot;&gt;) { &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;try&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; { &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;for&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; (Bean bean : beans) { &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt; 放到map集合中，通过key找到value，实例化该对象&lt;/span&gt; map.put(bean.getId(), Class.forName(bean.getClz()).newInstance());​ }​ } catch (ClassNotFoundException e) {​ e.printStackTrace();​ } catch (IllegalAccessException e) {​ e.printStackTrace();​ } catch (InstantiationException e) {​ e.printStackTrace();​ } } } &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;/**&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt; * xml解析 * * &lt;/span&gt;&lt;span style=&quot;color: #808080;&quot;&gt;@param&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt; fileName xml文件名 &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;*/&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;private&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;void&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; pathXml(String fileName) { &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt; 获取xml文件&lt;/span&gt; URL url = &lt;span style=&quot;color: #0000ff;&quot;&gt;this&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;.getClass().getClassLoader().getResource(fileName); &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;try&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; { &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt; (&lt;span style=&quot;color: #0000ff;&quot;&gt;null&lt;/span&gt; !=&lt;span style=&quot;color: #000000;&quot;&gt; url) { &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt; 获取解析器&lt;/span&gt; SAXReader saxReader = &lt;span style=&quot;color: #0000ff;&quot;&gt;new&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; SAXReader(); &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt; 解析xml文件，返回document对象&lt;/span&gt; Document document =&lt;span style=&quot;color: #000000;&quot;&gt; saxReader.read(url); &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt; 获取xpath对象&lt;/span&gt; XPath xPath = document.createXPath(&quot;beans/bean&quot;&lt;span style=&quot;color: #000000;&quot;&gt;); &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt; 查询选择的节点，返回的是list集合&lt;/span&gt; List&amp;lt;Element&amp;gt; elements =&lt;span style=&quot;color: #000000;&quot;&gt; xPath.selectNodes(document); &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt; 为空判断&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt; (&lt;span style=&quot;color: #0000ff;&quot;&gt;null&lt;/span&gt; != elements &amp;amp;&amp;amp; elements.size() &amp;gt; 0&lt;span style=&quot;color: #000000;&quot;&gt;) { &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;for&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; (Element element : elements) { &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt; 获取property&lt;/span&gt; xPath = document.createXPath(&quot;property&quot;&lt;span style=&quot;color: #000000;&quot;&gt;); &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt; 查询选择的节点&lt;/span&gt; List&amp;lt;Element&amp;gt; subElements =&lt;span style=&quot;color: #000000;&quot;&gt; xPath.selectNodes(element); &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt; 为空判断&lt;/span&gt; List&amp;lt;Property&amp;gt; properties = &lt;span style=&quot;color: #0000ff;&quot;&gt;null&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;; &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt; 实例化Bean&lt;/span&gt; Bean bean = &lt;span style=&quot;color: #0000ff;&quot;&gt;new&lt;/span&gt; Bean(element.attributeValue(&quot;id&quot;), element.attributeValue(&quot;class&quot;&lt;span style=&quot;color: #000000;&quot;&gt;)); &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt; (&lt;span style=&quot;color: #0000ff;&quot;&gt;null&lt;/span&gt; != subElements &amp;amp;&amp;amp; subElements.size() &amp;gt; 0&lt;span style=&quot;color: #000000;&quot;&gt;) { properties &lt;/span&gt;= &lt;span style=&quot;color: #0000ff;&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span style=&quot;color: #000000;&quot;&gt;(); &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;for&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; (Element subElement : subElements) { &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt; 实例化Property&lt;/span&gt; Property property = &lt;span style=&quot;color: #0000ff;&quot;&gt;new&lt;/span&gt; Property(subElement.attributeValue(&quot;id&quot;), subElement.attributeValue(&quot;ref&quot;&lt;span style=&quot;color: #000000;&quot;&gt;)); &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt; 将对象放到集合中&lt;/span&gt; properties.add(property);​ }​ bean.setProperties(properties);​ }​ beans.add(bean);​ }​ }​ }​ } catch (DocumentException e) {​ e.printStackTrace();​ }​ } @Override &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;public&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; Object getObj(String name) { &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt; 通过id返回class&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;return&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; map.get(name); } }View Code &nbsp; 四、Spring多文件的加载情况 1、ClassPathXmlApplicationContext类的构造器参数是一个可变长参数 可同时配置多个xml文件 2、import标签，将自配置文件导入总配置 &nbsp; 四、Spring Ioc实例化bean的三种方式 1、构造器的方式实例化bean对象 通过默认构造器实例化bean对象，默认空构造器必须存在 &nbsp; 2、静态工厂方式实例化bean 要有工厂类和静态工厂方法 通过反射调用静态工厂的静态方法，将该静态方法的返回值作为bean的实例，可以统一管理各个bean的创建 &nbsp; &nbsp; 3、实例化工厂方式实例化bean 工厂类和实例化方法 工厂方法为非静态，需要配置工厂bean，并在bean中配置factory-bean和factory-method属性 1) 可用于集成其他框架的bean创建管理方法&nbsp; 2)能够使bean和factory的角色互换 &nbsp; 五、Spring 依赖注入 在面向接口编程中，依赖接口可以动态传入多种实现 1、set注入 property标签，属性的set方法（不会出现循环引用问题） name：属性名称；ref：bean对象的引用；value：给属性直接赋值（List，Set，Map，properties） 2、构造器注入 constructor-arg标签，带参构造器（会出现循环引用问题，彼此互相依赖对方导致bean无法实例化） name：属性名称；ref：bean对象id的引用；index：属性的索引 &nbsp; 3、静态工厂注入 &nbsp; 4、实例化工厂注入 &nbsp; 六、注解方式注入bean xml配置：加入context命名空间和xsd地址 添加&lt;context:annotation-config/&gt;配置 &nbsp; @Resource （属于J2EE） @Autowired （Spring） 常用于属性字段或set方法上 区别： @Autowired 默认按bean的类型匹配，和@Qualifier配合使用可以修改按名称匹配 @Resource 默认按名称进行装配，可以通过name属性指定，如果没有指定name属性，当注解写在字段上时，默认取字段名进行匹配注入，如果注解写在set方法上默认取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配（当name属性指定，只会按照名称装配） &nbsp; 注解方式注入的简单模拟： import com.shsxt.annotaioms.Component;import com.shsxt.annotaioms.Component02;import com.shsxt02.controller.UserController; import java.io.File;import java.lang.reflect.Field;import java.net.URL;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map; public class Test { &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;private&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;static&lt;/span&gt; List&amp;lt;String&amp;gt; clz=&lt;span style=&quot;color: #0000ff;&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span style=&quot;color: #000000;&quot;&gt;(); &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;private&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;static&lt;/span&gt; Map&amp;lt;String,Object&amp;gt; map=&lt;span style=&quot;color: #0000ff;&quot;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span style=&quot;color: #000000;&quot;&gt;(); &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;public&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;static&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;void&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; main(String[] args){ String pkg&lt;/span&gt;=&quot;com.shsxt02&quot;&lt;span style=&quot;color: #000000;&quot;&gt;; &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt; 获取标记注解的类&lt;/span&gt; getClZ(pkg);​ // 实例化这些类 instanceClz();​ // 属性赋值 property();​ UserController userController= (UserController) map.get(“userController”);​ userController.test();​ } &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;private&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;static&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;void&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; property() { &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;try&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; { &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt; (&lt;span style=&quot;color: #0000ff;&quot;&gt;null&lt;/span&gt;!=&lt;span style=&quot;color: #000000;&quot;&gt;map){ &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;for&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;(Map.Entry entry:map.entrySet()){ Field[] fields&lt;/span&gt;=&lt;span style=&quot;color: #000000;&quot;&gt;entry.getValue().getClass().getDeclaredFields(); &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt; (&lt;span style=&quot;color: #0000ff;&quot;&gt;null&lt;/span&gt;!=&lt;span style=&quot;color: #000000;&quot;&gt;fields){ &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;for&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;(Field field:fields){ Component02 component02&lt;/span&gt;=field.getAnnotation(Component02.&lt;span style=&quot;color: #0000ff;&quot;&gt;class&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;); &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt; (&lt;span style=&quot;color: #0000ff;&quot;&gt;null&lt;/span&gt;!=&lt;span style=&quot;color: #000000;&quot;&gt;component02){ field.setAccessible(&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;true&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;); field.set(entry.getValue(),map.get(component02.value())); } } } } } } &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;catch&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; (IllegalAccessException e) { e.printStackTrace(); } } &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;private&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;static&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;void&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; instanceClz() { &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;try&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; { &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt; (&lt;span style=&quot;color: #0000ff;&quot;&gt;null&lt;/span&gt;!=clz &amp;amp;&amp;amp; clz.size()&amp;gt;0&lt;span style=&quot;color: #000000;&quot;&gt;){ &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;for&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;(String cls:clz){ &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;System.out.println(str);&lt;/span&gt; cls=cls.replace(&quot;.class&quot;,&quot;&quot;&lt;span style=&quot;color: #000000;&quot;&gt;); &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;System.out.println(cls);&lt;/span&gt; Component component=Class.forName(cls).getAnnotation(Component.&lt;span style=&quot;color: #0000ff;&quot;&gt;class&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;); &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt; (&lt;span style=&quot;color: #0000ff;&quot;&gt;null&lt;/span&gt;!=&lt;span style=&quot;color: #000000;&quot;&gt;component){ &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;System.out.println(cls);&lt;/span&gt; String id=&lt;span style=&quot;color: #000000;&quot;&gt; getId(cls); Object obj&lt;/span&gt;=&lt;span style=&quot;color: #000000;&quot;&gt;Class.forName(cls).newInstance(); map.put(id,obj); } } } } &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;catch&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; (ClassNotFoundException e) { e.printStackTrace(); } &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;catch&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; (IllegalAccessException e) { e.printStackTrace(); } &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;catch&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; (InstantiationException e) { e.printStackTrace(); } } &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;private&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;static&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; String getId(String cls) { cls&lt;/span&gt;=cls.substring(cls.lastIndexOf(&quot;.&quot;)+1&lt;span style=&quot;color: #000000;&quot;&gt;); cls&lt;/span&gt;= cls.toLowerCase().charAt(0)+cls.substring(1&lt;span style=&quot;color: #000000;&quot;&gt;); &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;return&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; cls; } &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;private&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;static&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;void&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; getClZ(String pkg) { &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt; 获取url&lt;/span&gt; URL url=&lt;span style=&quot;color: #000000;&quot;&gt;Thread.currentThread().getContextClassLoader().getResource(repStr(pkg)); String urlPath&lt;/span&gt;=&lt;span style=&quot;color: #000000;&quot;&gt;url.getFile(); &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;System.out.println(urlPath);&lt;/span&gt; String[] subFileStrs=&lt;span style=&quot;color: #0000ff;&quot;&gt;new&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; File(urlPath).list(); &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;for&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;(String str:subFileStrs){ String subFilePath&lt;/span&gt;=urlPath+&quot;/&quot;+&lt;span style=&quot;color: #000000;&quot;&gt;str; &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;System.out.println(subFilePath);&lt;/span&gt; File subFile=&lt;span style=&quot;color: #0000ff;&quot;&gt;new&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; File(subFilePath); &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; (subFile.isDirectory()){ &lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt;System.out.println(pkg+&quot;.&quot;+subFile.getName());&lt;/span&gt; getClZ(pkg+&quot;.&quot;+&lt;span style=&quot;color: #000000;&quot;&gt;subFile.getName()); }&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;else&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;{ clz.add(pkg&lt;/span&gt;+&quot;.&quot;+&lt;span style=&quot;color: #000000;&quot;&gt;subFile.getName()); } } } &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;private&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;static&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; String repStr(String str){ str&lt;/span&gt;=str.replace(&quot;.&quot;,&quot;/&quot;&lt;span style=&quot;color: #000000;&quot;&gt;); &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;return&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; str; } } &nbsp; 七、Spring IOC 容器自动扫描管理bean xml配置&lt;context:component-scan base-package=””/&gt; 建议的注解 Dao层：@Repository Service层：@Service 控制层：@Controller 不明确：@Component &nbsp; 八、Bean的作用域问题(scope) 1、singleton作用域（单例，默认） lazy-init 懒加载 默认为false 如果等于true时，spring容器启动的时候不会去实例化这个bean，而是在程序调用时才会去实例化 在启动情况下实例化所有singleton的bean对象并缓存与容器中单例的好处： 1、提前发现潜在的配置问题 2、bean对象存在于缓存中，使用时不用再实例化bean，提高执行性能 无状态对象适合做单例bean对象（无可变的成员变量） &nbsp; 2、prototype作用域（原型） 每次向Spring容器请求获取Bean都返回一个全新的Bean，相对于&ldquo;singleton&rdquo;来说就是不缓存Bean。IOC不会维护该对象 &nbsp; 3、Web应用中的作用域（request、session、globalsession） request作用域：每一次请求 session：当前会话 globlasession：同session（Portlet环境）]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Spring-AOP]]></title>
    <url>%2Fdlh1234okok.github.io%2F2018%2F10%2F04%2FSpring-AOP%2F</url>
    <content type="text"><![CDATA[一、代理模式 1、代理模式的设计原则： &middot;代理类与委托类具有相似的行为 &middot;代理类增强委托类的行为 2、代理模式实现的三要素： 代理角色、目标角色、共同行为 实现行为接口，持有目标对象的引用 &nbsp; 3、静态代理和动态代理 1）静态代理 特点：程序运行前制作代理角色 代理目标角色单一 代理类数量无法控制 2）动态代理 程序运行期动态创建代理角色 &middot;JDK动态代理，回调方式实现 &middot;cglib动态代理，继承方式实现 区别： JDK动态代理：委托类必须要有接口，制作过程较快，执行慢 Cglib动态代理：委托类可以没有接口，继承的思维来实现相似性，制作代理过程比较慢，执行快 &nbsp; 二、AOP（面相切面编程） AOP的两种实现机制是JDK动态代理和cglib动态代理 AOP主要应用于日志记录，性能统计，安全控制，事务处理额等方面，实现公共行为的重复使用 降低模块之间的耦合度，提高业务代码的聚合度（高内聚低耦合） 提高代码的复用性 提高系统的扩展性 Aop基本概念 Joinpoint（连接点）：spring中指被拦截到的每一个方法 Pointcut（切入点）：规定拦截哪些方法，对那些方法进行处理 Advice（通知）：拦截到每一个连接点后要做的操作 前置通知、返回通知、最终通知、异常通知、环绕通知 Aspect（切面）：切入点与通知的结合 Target（目标对象）：被代理的目标对象 Weave（织入） Introduction（引入） &nbsp; 三、AOP注解实现 1、XML：引入命名空间，开启aop代理环境 2、Maven项目引入Aspect坐标 3、创建切面类 @Aspect定义切面类 4、声明方法为切入点 @Pointcut 匹配规则定义 execution 5、创建通知方法 package com.shsxt02.proxy;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.;import org.springframework.stereotype.Component;@Aspect@Componentpublic class LogCut { @Pointcut(“execution( com.shsxt02.service...(..))”) public void cut() { } @After(value = “cut()”) public void before(){ System.out.println(“前置通知，目标方法执行前执行…”); } @AfterReturning(value = “cut()”) public void afterReturn(){ System.out.println(“返回通知，方法正常结束后执行…”); } @After(value = “cut()”) public void after(){ System.out.println(“最终通知，方法是否发生异常均会执行…”); } @AfterThrowing(value = “cut()”,throwing = “e”) public void afterThrow(Exception e){ System.out.println(“异常通知，异常时执行…”+e); } // 环绕通知 @Around(value = “cut()”) public Object around(ProceedingJoinPoint pjp) throws Throwable { Object result=null; System.out.println(“环绕前置…”); System.out.println(“环绕通知…”); System.out.println(“方法签名”+pjp.getSignature()); System.out.println(“目标对象”+pjp.getTarget()); System.out.println(“种类”+pjp.getKind()); Object[] objects=pjp.getArgs(); for(Object o:objects){ System.out.println(“参数”+o); } result= pjp.proceed(); // 返回的目标对象 System.out.println(“环绕后置…”); return result; }} &nbsp; 四、AOP XML配置实现 &nbsp; &nbsp; 五、AOP拦截注释 &nbsp; 如果目标角色实现了接口，AOP有代理，返回的是代理对象，需要通过接口接收。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Spring-定时器和邮件发送]]></title>
    <url>%2Fdlh1234okok.github.io%2F2018%2F10%2F04%2FSpring-%E5%AE%9A%E6%97%B6%E5%99%A8%E5%92%8C%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81%2F</url>
    <content type="text"><![CDATA[一、定时器的实现（task） 1、在XML配置文件中引入约束 xmlns:task=”http://www.springframework.org/schema/task&quot; http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task.xsd 2、编写定时器类，和方法 &nbsp; 3、使用xml配置文件 加载配置文件就可以执行定时任务了，图为两秒执行一次。 &nbsp; 二、邮件发送 1、Java mail发送邮件 1) Maven项目引入java mail坐标，也可以手动安装 package com.shsxt.service;import org.apache.commons.lang3.StringUtils;import javax.activation.DataHandler;import javax.activation.DataSource;import javax.activation.FileDataSource;import javax.mail.;import javax.mail.internet.;import java.io.File;import java.io.UnsupportedEncodingException;import java.nio.charset.Charset;import java.util.Properties;public class MailService { public void mail(String fromUser, String[] receivers, String setSubject, String content, String[] files) { // 判断参数是否为空 if (!judgment(fromUser, receivers, setSubject, content)){ return; } // 获取session Session session = init(fromUser); Message message = new MimeMessage(session); // 发送人 sender(fromUser, message);​ // 收件人 recipients(receivers, message);​ // 主题 subject(message,setSubject);​ // 设置html和附件​ Multipart multipart = new MimeMultipart();​ // html内容 Content(content, multipart);​ // 判断是否有附件​ if (null != files &amp;&amp; files.length &gt; 0) {​ // 上传附件 fileUp(files, multipart);​ }​ settingContext(message, multipart);​ // 发送 send(message);​ } // 8、发送 private void send(Message message) { try { Transport.send(message); } catch (MessagingException e) { e.printStackTrace(); } } // 7、设置上下文 private void settingContext(Message message, Multipart multipart) { try { message.setContent(multipart); } catch (MessagingException e) { e.printStackTrace(); } } // 6、设置主题 private void subject(Message message,String setSubject) { try { message.setSubject(setSubject); } catch (MessagingException e) { e.printStackTrace(); } } // 5、上传附件 private void fileUp(String[] files, Multipart multipart) { try { for (String filePath : files) { BodyPart file = new MimeBodyPart(); File temp = new File(filePath); file.setDataHandler(new DataHandler(new FileDataSource(new File(filePath)))); file.setFileName(MimeUtility.encodeText(temp.getName())); multipart.addBodyPart(file); } } catch (Exception e) { e.printStackTrace(); } } // 4、设置html内容 private void Content(String content, Multipart multipart) { try { BodyPart html = new MimeBodyPart(); html.setContent(content, “text/html;charset=utf-8”); multipart.addBodyPart(html); } catch (MessagingException e) { e.printStackTrace(); } } // 3、设置收件人 private void recipients(String[] receivers, Message message) { try { Address[] addresses = new InternetAddress[receivers.length]; for (int i = 0; i &lt; addresses.length; i++) { addresses[i] = new InternetAddress(receivers[i]); } message.setRecipients(Message.RecipientType.TO, addresses); } catch (MessagingException e) { e.printStackTrace(); } } // 2、设置发送人 private void sender(String fromUser, Message message) { try { Address from = new InternetAddress(fromUser); message.setFrom(from); } catch (Exception e) { e.printStackTrace(); } } // 1、初始化 private Session init(String fromUser) { Properties properties = new Properties(); // 邮箱服务器主机 properties.put(“mail.smtp.host”, “smtp.163.com”); properties.put(“mail.smtp.auth”, “true”); properties.put(“mail.smtp.port”, 25); Session session = Session.getDefaultInstance(properties, new Authenticator() { @Override protected PasswordAuthentication getPasswordAuthentication() { return new PasswordAuthentication(“15657262398@163.com“, “d140120”); } }); return session; } // 0、判断参数是否为空 private boolean judgment(String fromUser, String[] receivers, String setSubject, String content) { boolean flag = true; if (StringUtils.isBlank(fromUser) || StringUtils.isAnyBlank(receivers) || StringUtils.isBlank(setSubject) || StringUtils.isBlank(content)) { flag = false; } return flag; }} &nbsp; 2、spring环境下发送邮件 XML配置 &lt;?xml version=”1.0” encoding=”UTF-8”?&gt;&lt;beans xmlns=”http://www.springframework.org/schema/beans&quot; xmlns:xsi=”http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=”http://www.springframework.org/schema/context&quot; xsi:schemaLocation=”http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:component-scan base-package=”com.mail”/&gt; &lt;bean id=”mailSender” class=”org.springframework.mail.javamail.JavaMailSenderImpl”&gt; &lt;property name=”host” value=”smtp.163.com”/&gt;&lt;!–发送email的邮件服务器主机名–&gt; &lt;property name=”username” value=”test@163.com“/&gt;&lt;!–用户名–&gt; &lt;property name=”password” value=”test”/&gt;&lt;!–授权码–&gt; &lt;/bean&gt; &lt;bean id=”simpleMailMessage” class=”org.springframework.mail.SimpleMailMessage”&gt; &lt;property name=”subject” value=”hello mail”/&gt; &lt;property name=”from” value=”15657262398@163.com“/&gt; &lt;/bean&gt;&lt;/beans&gt; 装配和使用邮件发送器 package com.mail;import org.springframework.mail.MailSender;import org.springframework.mail.SimpleMailMessage;import org.springframework.stereotype.Service;import javax.annotation.Resource;@Servicepublic class OrderManagerImpl implements OrderManager { @Resource private MailSender mailSender; @Resource private SimpleMailMessage simpleMailMessage; @Override public void placeOrder() { SimpleMailMessage msg=new SimpleMailMessage(this.simpleMailMessage); msg.setTo(“test@163.com“); msg.setText(“hello”); this.mailSender.send(msg); }} &nbsp;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Spring-整合JDBC-事务-远程方法调用RMI]]></title>
    <url>%2Fdlh1234okok.github.io%2F2018%2F10%2F04%2FSpring-%E6%95%B4%E5%90%88JDBC-%E4%BA%8B%E5%8A%A1-%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8RMI%2F</url>
    <content type="text"><![CDATA[一、spring整合JDBC spring整合jdbc使用了模版方法设计模式 定义一套规范，固定流程不变，传入可变内容 1、Maven项目添加依赖 spring-context坐标依赖 mysql驱动包 c3p0连接池 spring jdbc 2、准备数据库的配置文件 3、xml配置 &lt;?xml version=”1.0” encoding=”UTF-8”?&gt;&lt;beans xmlns=”http://www.springframework.org/schema/beans&quot; xmlns:xsi=”http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=”http://www.springframework.org/schema/context&quot; xsi:schemaLocation=”http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!–配置扫描器–&gt; &lt;context:component-scan base-package=”com.shsxt”/&gt; &lt;!–加载properties–&gt; &lt;context:property-placeholder location=”classpath:jdbc.properties”/&gt; &lt;!–配置数据源c3p0–&gt; &lt;bean id=”dataSource” class=”com.mchange.v2.c3p0.ComboPooledDataSource”&gt; &lt;property name=”driverClass” value=”${jdbc.driver}”/&gt; &lt;property name=”jdbcUrl” value=”${jdbc.url}”/&gt; &lt;property name=”user” value=”${jdbc.user}”/&gt; &lt;property name=”password” value=”${jdbc.password}”/&gt; &lt;/bean&gt; &lt;!–配置JdbcTemplate–&gt; &lt;bean id=”jdbcTemplate” class=”org.springframework.jdbc.core.JdbcTemplate”&gt; &lt;property name=”dataSource” ref=”dataSource”/&gt; &lt;/bean&gt;&lt;/beans&gt; 这里使用了c3p0数据源 C3P0有自动回收空闲连接功能； dbcp没有自动回收空闲连接功能； 4、使用spring jdbc完成crud操作 package com.shsxt;import com.shsxt.po.Account;import com.sun.xml.internal.bind.v2.model.core.ID;import org.apache.commons.lang3.StringUtils;import org.springframework.jdbc.core.BatchPreparedStatementSetter;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.PreparedStatementCreator;import org.springframework.jdbc.core.RowMapper;import org.springframework.jdbc.support.GeneratedKeyHolder;import org.springframework.jdbc.support.KeyHolder;import org.springframework.stereotype.Component;import org.springframework.stereotype.Repository;import javax.annotation.Resource;import javax.lang.model.element.Name;import java.math.BigDecimal;import java.sql.;import java.util.ArrayList;import java.util.List;@Repositorypublic class AccountDaoImpl implements AccountDao {​ @Resource​ private JdbcTemplate jdbcTemplate; /** 添加记录返回受影响行数 @param account @return / @Override public Integer saveAccount(Account account) { String sql=”insert into account (name,type,money,remark,create_time,update_time,userId) values(?,?,?,?,?,?,?)”; return jdbcTemplate.update(sql,account.getName(),account.getType(),account.getMoney(),account.getRemark(),account.getCreate_time(),account.getUpdate_time(),account.getUserId()); } /** 添加记录返回主键 @param account @return / @Override public Integer saveAccountHasPrimaryKey(Account account) { String sql=”insert into account (name,type,money,remark,create_time,update_time,userId) values(?,?,?,?,?,?,?)”; KeyHolder keyHolder=new GeneratedKeyHolder(); jdbcTemplate.update(new PreparedStatementCreator() { @Override public PreparedStatement createPreparedStatement(Connection con) throws SQLException { PreparedStatement ps=con.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS); ps.setString(1,account.getName()); ps.setString(2,account.getType()); ps.setBigDecimal(3,account.getMoney()); ps.setString(4,account.getRemark()); ps.setObject(5,account.getCreate_time()); ps.setObject(6,account.getUpdate_time()); ps.setInt(7,account.getUserId()); return ps; } },keyHolder); return keyHolder.getKey().intValue(); } /** 批量添加记录 @param accounts @return / @Override public Integer saveAccountsBatch(List&lt;Account&gt; accounts) { String sql=”insert into account (name,type,money,remark,create_time,update_time,userId) values(?,?,?,?,?,?,?)”; return jdbcTemplate.batchUpdate(sql, new BatchPreparedStatementSetter() { @Override public void setValues(PreparedStatement ps, int i) throws SQLException { ps.setString(1,accounts.get(i).getName()); ps.setString(2,accounts.get(i).getType()); ps.setBigDecimal(3,accounts.get(i).getMoney()); ps.setString(4,accounts.get(i).getRemark()); ps.setObject(5,accounts.get(i).getCreate_time()); ps.setObject(6,accounts.get(i).getUpdate_time()); ps.setInt(7,accounts.get(i).getUserId()); } @Override public int getBatchSize() { return accounts.size(); } }).length; } /** 统计账户记录-聚合查询 @param userId @return / @Override public Integer countAccountsByUserId(Integer userId) { String sql=”select count(1) from account where userId=?”; return jdbcTemplate.queryForObject(sql,Integer.class,userId); } /** 根据id查询记录详情 @param Id @return / @Override public Account queryAccountById(Integer Id) { String sql=”select id,userId,name,type,money,remark,update_time,create_time from account where id=?”; return (Account) jdbcTemplate.queryForObject(sql,new Object[]{Id}, new RowMapper&lt;Account&gt;() { @Override public Account mapRow(ResultSet rs, int rowNum) throws SQLException { Account account=new Account(); account.setUpdate_time(rs.getDate(“update_time”)); account.setRemark(rs.getString(“remark”)); account.setType(rs.getString(“type”)); account.setMoney(rs.getBigDecimal(“money”)); account.setCreate_time(rs.getDate(“create_time”)); account.setId(rs.getInt(“id”)); account.setName(rs.getString(“name”)); account.setUserId(rs.getInt(“userId”)); return account; } }); } /** 多条件查询 @param userId @param type @param createTime @param aname @return / @Override public List&lt;Account&gt; queryAccountsByParams(Integer userId, String type, String createTime, String aname) { StringBuffer sql=new StringBuffer(“select id,userId,name,type,money,remark,update_time,create_time from account where 1=1”); List&lt;Object&gt; params=new ArrayList&lt;&gt;(); if (null!=userId){ sql.append(“ and userId=?”); params.add(userId); } if (StringUtils.isNotBlank(type)){ sql.append(“ and type=? “); params.add(type); } if (StringUtils.isNotBlank(createTime)){ sql.append(“ and createTime=?”); params.add(createTime); } if (StringUtils.isNotBlank(aname)){ sql.append(“ and name=?”); params.add(aname); } return jdbcTemplate.query(sql.toString(), params.toArray(), new RowMapper&lt;Account&gt;() { @Override public Account mapRow(ResultSet rs, int rowNum) throws SQLException { Account account=new Account(); account.setId(rs.getInt(“id”)); account.setUserId(rs.getInt(“userId”)); account.setName(rs.getString(“name”)); account.setCreate_time(rs.getDate(“create_time”)); account.setMoney(rs.getBigDecimal(“money”)); account.setType(rs.getString(“type”)); account.setRemark(rs.getString(“remark”)); account.setUpdate_time(rs.getDate(“update_time”)); return account; } }); } @Override public Integer updateAccount(Account account) { String sql=”update account set name=?,type=?,money=? where id=?”; return jdbcTemplate.update(sql,account.getName(),account.getType(),account.getMoney(),account.getId()); } / 批量更新 @param accounts @return / @Override public Integer updateAccountsBatch(List&lt;Account&gt; accounts) { String sql=”update account set name=?,type=?,money=? where id=?”; return jdbcTemplate.batchUpdate(sql, new BatchPreparedStatementSetter() { @Override public void setValues(PreparedStatement ps, int i) throws SQLException { ps.setString(1,accounts.get(i).getName()); ps.setString(2,accounts.get(i).getType()); ps.setBigDecimal(3,accounts.get(i).getMoney()); ps.setInt(4,accounts.get(i).getId()); } @Override public int getBatchSize() { return accounts.size(); } }).length; } / 根据id删除记录 @param id @return / @Override public Integer deleteAccountById(Integer id) { String sql=”delete from account where id=?”; return jdbcTemplate.update(sql,id); } /* 批量删除 @param ids @return */ @Override public Integer deleteAccountsBatch(Integer[] ids) { String sql=”delete from account where id=?”; return jdbcTemplate.batchUpdate(sql, new BatchPreparedStatementSetter() { @Override public void setValues(PreparedStatement ps, int i) throws SQLException { ps.setInt(1,ids[i]); } @Override public int getBatchSize() { return ids.length; } }).length; } @Override public Integer inMoney(Integer sourceId, BigDecimal money) { String sql=”update account set money=money-? where id=?”; return jdbcTemplate.update(sql,money,sourceId); } @Override public Integer outMoney(Integer targetId, BigDecimal money) { String sql=”update account set money=money+? where id=?”; return jdbcTemplate.update(sql,money,targetId); }}crud &nbsp; 二、spring事务 1、事务的四大特性（ACID） 原子性(Atomicity)：共生死，要么全部成功，要么全部失败 一致性(Consistency)：事务在执行前后，数据库中数据要保持一致性状态 隔离性(Lsolation)：事务与事务之间的执行应当是相互隔离互不影响的 持久性(Durability)：事务提交完毕后，数据库中的数据的改变是永久的 &nbsp; 2、事务配置 1)、添加坐标依赖 aop、spring事务 2)、XML配置 修改xml命名空间 xmlns:tx=”http://www.springframework.org/schema/tx&quot; http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd &lt;!–aop代理–&gt; &lt;aop:aspectj-autoproxy/&gt; &lt;!–事务配置–&gt; &lt;bean id=”txManager” class=”org.springframework.jdbc.datasource.DataSourceTransactionManager”&gt; &lt;property name=”dataSource” ref=”dataSource”/&gt; &lt;/bean&gt; &lt;!–事务通知配置–&gt; &lt;tx:advice id=”txAdvice” transaction-manager=”txManager”&gt; &lt;tx:attributes&gt; &lt;!–配置事务要拦截的方法–&gt; &lt;tx:method name=”save“ propagation=”REQUIRED”/&gt; &lt;tx:method name=”update“ propagation=”REQUIRED”/&gt; &lt;tx:method name=”del“ propagation=”REQUIRED”/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!–aop切面定义–&gt;​ &lt;aop:config&gt;​ &lt;aop:pointcut id=”cut” expression=”execution( com.shsxt.service...(..))”&gt;&lt;/aop:pointcut&gt;​ &lt;aop:advisor advice-ref=”txAdvice” pointcut-ref=”cut”/&gt;​ &lt;/aop:config&gt; &lt;!–注解方式配置事务，可以和xml配置共同使用–&gt; &lt;tx:annotation-driven transaction-manager=”txManager”/&gt; &nbsp; 3)、注解使用事务，xml配置后在方法上添加注解 4)、事务传播行为 &nbsp; 三、远程方法调用RMI Java RMI 指的是远程方法调用 (Remote Method Invocation)。它是一种机制，能够让在某个 Java 虚拟机上的对象调用另一个 Java 虚拟机中的对象上的方法。 JVM 可以位于相同或不同计算机上，在多个 JVM 中，一个 JVM 可以调用存储在其它 JVM 的对象的方法。 具体实现先不写了，我还没弄清楚。待修改]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux基本命令和项目发布]]></title>
    <url>%2Fdlh1234okok.github.io%2F2018%2F10%2F04%2FLinux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E5%92%8C%E9%A1%B9%E7%9B%AE%E5%8F%91%E5%B8%83%2F</url>
    <content type="text"><![CDATA[一、基本命令 date：查看当前日期 pwd：查看当前位置 cd：目录切换 ls|ll：查看当前目录文件与文件夹 mkdir+目录名：创建文件夹（可创建多个） rm -rf +目录：删除文件夹（可删除多个） mv 原始目录&nbsp; 修改后目录&nbsp; 文件移动/重命名 vim 文件名：创建或打开文件 i，编辑状态；esc退出编辑状态 &nbsp; &nbsp;：wq&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;写入并退出，：q&nbsp; &nbsp; 退出 cp 源文件地址&nbsp; 目标文件目录：文件copy cp -r 源文件夹目录&nbsp; 目标文件夹目录：文件夹copy &nbsp; 二、项目发布到Linux配置 1、静态ip配置步骤 1.选择桥接模式 2.启动后修改网卡文件 vi&nbsp; /etc/sysconfig/network-scripts/ifcfg-eth0&nbsp; 修改ip地址 执行测试 ping 192.168.1.1 ping 192.168.1.188 ping ***.com &nbsp; 2、连接终端(我使用了xshell) &nbsp; 3、安装jdk yum list|grep jdk&nbsp; &nbsp;查找jdk相关软件 yum install jdk.xxx&nbsp; &nbsp; 安装指定版本jdk 4、安装tomcat wget+tomcat下载地址 ./startup.sh&nbsp; &nbsp;在bin目录下执行启动脚本 关闭tomcat： ./shutdown.sh&nbsp; 执行脚本关闭 ps -ef|grep tomcat 查找tomcat相关进程 kill -9&nbsp; 进程号&nbsp; 关闭相关进程 5、防火墙设置 service iptables status&nbsp; &nbsp;查看防火墙状态 service iptables stop&nbsp; &nbsp;关闭防火墙 &nbsp; 测试..外部输入ip访问tomcat主页 &nbsp; 6、mysql安装和配置 查看mysql安装历史 rpm -qa | grep mysql 卸载mysql yum -y remove mysql 安装mysql yum -y install mysql-server mysql mysql-devel &nbsp; 启动服务 service mysqld start 启动 service mysqld stop 停止 service mysqld restart 重启 &nbsp; 创建管理员 mysqladmin&nbsp; -u&nbsp; root&nbsp; &nbsp;password&nbsp; *** 执行登录 mysql&nbsp; -uroot&nbsp; &nbsp;-p*** 授权 grant all privileges on . to ‘用户名‘@’%’ identified by ‘密码串’ with grant option; FLUSH&nbsp; &nbsp;PRIVILEGES; &nbsp; &nbsp; 使用sqlyog | navicat 进行连接 &nbsp; 7、将打包好的war包放到tomcat/webapp目录下，启动tomcat（项目名为站点名） &nbsp; 三、idea Maven项目打包 本地环境&nbsp; dev 测试环境&nbsp; test 生产环境&nbsp; product &nbsp; 配置打包标签 &lt;profiles&gt; &lt;profile&gt; &lt;id&gt;dev&lt;/id&gt; &lt;properties&gt; &lt;env&gt;dev&lt;/env&gt; &lt;/properties&gt; &lt;activation&gt; &lt;!– 默认运行开发环境 –&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;test&lt;/id&gt; &lt;properties&gt; &lt;env&gt;test&lt;/env&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;product&lt;/id&gt; &lt;properties&gt; &lt;env&gt;product&lt;/env&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;/profiles&gt; 指定资源文件 &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources/${env}&lt;/directory&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;/*.xml&lt;/include&gt; &lt;include&gt;/.properties&lt;/include&gt; &lt;include&gt;**/.tld&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; 打包命令配置 clean&nbsp; compile package -Dmaven.test.skip=true -Ptest|dev|product 清理编译文件，打包跳过测试文件 test/dev/product 包]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用poi读取Excel和写出Excel]]></title>
    <url>%2Fdlh1234okok.github.io%2F2018%2F10%2F04%2F%E4%BD%BF%E7%94%A8poi%E8%AF%BB%E5%8F%96Excel%E5%92%8C%E5%86%99%E5%87%BAExcel%2F</url>
    <content type="text"><![CDATA[使用poi读取Excel和写出Excel本次使用到的jar包 &nbsp;&nbsp;1、从数据库读取数据写出到Excelpublic class CreateExcel01 { // 数据库查询 public static List&lt;Account&gt; query() { String sql = “select from tb_account”; List&lt;Account&gt; list = BaseDao.findRows(sql, null, Account.class); return list; } // 创建Excel public static void createExcel(){ try { // 获取桌面路径 FileSystemView fsv = FileSystemView.getFileSystemView(); String desktop = fsv.getHomeDirectory().getPath(); String filePath = desktop + “/account.xls”; File file = new File(filePath); OutputStream outputStream = new FileOutputStream(file); HSSFWorkbook workbook = new HSSFWorkbook(); // 创建一个工作表 HSSFSheet sheet = workbook.createSheet(“Sheet1”); // 创建首行/头（第0行开始） HSSFRow head = sheet.createRow(0); String[] header = new String[]{“账户id”,”账户名称”,”账户类型”,”账户金额”,”账户备注”,”创建时间”,”用户id”,”更新时间”}; for (int i=0;i&lt;header.length;i++){ // 设置首行信息 head.createCell(i).setCellValue(header[i]);​ }​ head.setHeightInPoints(20); // 设置行的高度 // 从数据查询返回的集合 List&lt;Account&gt; accounts=query(); // 日期格式化 HSSFCellStyle cellStyle2 = workbook.createCellStyle(); HSSFCreationHelper creationHelper = workbook.getCreationHelper(); // 设置日期格式 cellStyle2.setDataFormat(creationHelper.createDataFormat().getFormat(“yyyy-MM-dd HH:mm:ss”)); sheet.setColumnWidth(3, 15 256); sheet.setColumnWidth(5, 20 256); sheet.setColumnWidth(7, 20 256);// 设置列的宽度 // 保留两位小数 HSSFCellStyle cellStyle3 = workbook.createCellStyle(); cellStyle3.setDataFormat(HSSFDataFormat.getBuiltinFormat(“0.00”)); for(int i=0;i&lt;accounts.size();i++) { // 创建行（从第一行开始） HSSFRow row1 = sheet.createRow(i + 1); // id row1.createCell(0).setCellValue(accounts.get(i).getId()); // 账户名称 row1.createCell(1).setCellValue(accounts.get(i).getAccountName()); // 账户类型 row1.createCell(2).setCellValue(accounts.get(i).getAccountType()); // 账户金额（保留两位小数） HSSFCell money = row1.createCell(3); money.setCellStyle(cellStyle3); money.setCellValue(accounts.get(i).getMoney()); // 账户备注 row1.createCell(4).setCellValue(accounts.get(i).getRemark()); // 创建时间（格式化时间） HSSFCell date1 = row1.createCell(5); date1.setCellStyle(cellStyle2); date1.setCellValue(accounts.get(i).getCreateTime()); // 用户id row1.createCell(6).setCellValue(accounts.get(i).getUid()); // 更新时间 HSSFCell date2 = row1.createCell(7); date2.setCellStyle(cellStyle2); date2.setCellValue(accounts.get(i).getUpdateTime()); } workbook.setActiveSheet(0); workbook.write(outputStream); outputStream.close(); } catch (IOException e1) { e1.printStackTrace(); } }}&nbsp;&nbsp;2、从Excel读取写入到数据库package com.shsxt;import org.apache.commons.lang3.time.DateFormatUtils;import org.apache.poi.hssf.usermodel.HSSFCell;import org.apache.poi.hssf.usermodel.HSSFDataFormat;import org.apache.poi.hssf.usermodel.HSSFDateUtil;import org.apache.poi.hssf.usermodel.HSSFWorkbook;import org.apache.poi.ss.formula.functions.Rows;import org.apache.poi.ss.usermodel.;import org.apache.poi.xssf.usermodel.XSSFWorkbook;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Date;import java.util.Iterator;import java.util.List;public class ReadExcelToDB { public List&lt;List&lt;Object&gt;&gt; importExcel(File file) { List&lt;List&lt;Object&gt;&gt; dataList = null; try { dataList = new ArrayList&lt;List&lt;Object&gt;&gt;(); // Excel对象 Workbook workbook = null; // 获取文件名 String fileName = file.getName().toLowerCase(); // 判断后缀 if (fileName.endsWith(“xls”)) { workbook = new HSSFWorkbook(new FileInputStream(file)); } else if (fileName.endsWith(“xlsx”)) { workbook = new XSSFWorkbook(new FileInputStream(file)); } else { throw new RuntimeException(“该文件不是Excel文件”); } // 获取Excel中的第一个表格 Sheet sheet = workbook.getSheet(“Sheet1”); // 得到表格中的数据的行数，最后一行 int rows = sheet.getLastRowNum(); if (rows == 0) { throw new RuntimeException(“表格中没有数据”); } Row row = null; //行对象 Iterator&lt;Cell&gt; cols = null; // 列对象的迭代器 List&lt;Object&gt; list = null; for (int i = 1; i &lt;= rows; i++) { row = sheet.getRow(i); // 获取第i行 if (row != null) { cols = row.cellIterator(); // 获取该行的迭代器 list = new ArrayList&lt;Object&gt;(); while (cols.hasNext()) { // 循环获取每一列数据存到list中 list.add(getCellObj(cols.next()));​ }​ // 将这行数据存到集合dataList中 dataList.add(list);​ }​ }​ } catch (IOException e) {​ e.printStackTrace();​ }​ return dataList;​ } private Object getCellObj(Cell cell) { if (cell == null) { return “”; } Object cellObj; switch (cell.getCellType()) { case HSSFCell.CELL_TYPE_STRING: //字符串 cellObj = cell.getStringCellValue(); break; case HSSFCell.CELL_TYPE_NUMERIC: //数字 // poi把日期类型也归为数字类型 if (HSSFDateUtil.isCellDateFormatted(cell)){ // 获取日期对象并格式化 Date date=cell.getDateCellValue(); cellObj= DateFormatUtils.format(date,”yyyy-MM-dd”); } else{ /CellStyle cellStyle=cell.getCellStyle(); cellStyle.setDataFormat(HSSFDataFormat.getBuiltinFormat(“0”));*/ cellObj = cell.getNumericCellValue(); } break; case HSSFCell.CELL_TYPE_BOOLEAN: //boolean cellObj = cell.getBooleanCellValue(); break; case HSSFCell.CELL_TYPE_FORMULA: //公式 cellObj = cell.getCellFormula(); break; case HSSFCell.CELL_TYPE_BLANK: //空 cellObj = “”; break; case HSSFCell.CELL_TYPE_ERROR: //错误 cellObj = “”; break; default: cellObj=””; break; } return cellObj; }}class Test {​ public static void main(String[] args) {​ File file = new File(“C:\Users\Administrator\Desktop\no1.xls”);​ ReadExcelToDB readExcelToDB = new ReadExcelToDB();​ List&lt;List&lt;Object&gt;&gt; lists=readExcelToDB.importExcel(file);​ for (List&lt;Object&gt; ObjList:lists){​ for (Object object:ObjList){​ System.out.println(object);​ } System.out.println(“__“); ​ }​ }}&nbsp;读取的结果是：&nbsp;调用数据库插入就可以往插入到数据库了]]></content>
      <categories>
        <category>poi</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo]]></title>
    <url>%2Fdlh1234okok.github.io%2F2018%2F10%2F03%2Fhello-hexo%2F</url>
    <content type="text"><![CDATA[​ 花了一天半时间终于把这个博客建好了，中间遇到了很多坑，网上搜了大量资源，略有不足，以后想到了再改改漂亮吧。 ​ 我转了几篇之前在博客园的博客到这里，都是一篇篇从html转为markdown转换来的，但是发现好多文章的图片无法正常显示，暂时也没有更好的办法，作罢，不过以后我都会在这里更新。 ​ 贴一下我看的各位博主写的教程链接，方便以后出现问题可以解决。 ​ 1、这是我看的第一篇，初次接触给我帮助很大 ​ https://blog.csdn.net/dgut_guangdian/article/details/79326107 ​ 2、这几篇修改了next主题样式，添加了些好玩的东西 ​ https://blog.csdn.net/zhy421202048/article/details/77877580 ​ https://blog.csdn.net/w_ngzeqi/article/details/73863543 ​ https://blog.csdn.net/csdnSR/article/details/78300820 ​ https://www.jianshu.com/p/3a05351a37dc ​ ​ 3、在添加gitment评论时对我有帮助的（但我好像至今无法使用…） ​ https://www.cnblogs.com/pangguoming/p/8094815.html ​ https://www.jianshu.com/p/57afa4844aaa]]></content>
  </entry>
</search>
